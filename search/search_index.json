{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OMI glTF Extensions Documentation","text":"<p>Welcome to the documentation for OMI glTF Extensions. This site contains detailed information about various glTF extensions developed by OMI. Use the navigation menu on the left to explore different extensions.</p>"},{"location":"#available-extensions","title":"Available Extensions","text":"<ul> <li>KHR_audio_emitter</li> <li>OMI_audio_ogg_vorbis</li> <li>OMI_audio_opus</li> <li>OMI_link</li> <li>OMI_personality</li> <li>OMI_physics_body</li> <li>Collider</li> <li>Motion</li> <li>Trigger</li> <li>OMI_physics_gravity</li> <li>OMI_physics_joint</li> <li>OMI_physics_shape</li> <li>OMI_seat</li> <li>OMI_spawn_point</li> </ul>"},{"location":"#archived-extensions","title":"Archived Extensions","text":"<ul> <li>OMI_collider</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started, choose an extension from the navigation menu on the left. Each extension's documentation provides detailed information about its usage, implementation details, and examples.</p>"},{"location":"#examples","title":"Examples","text":"<p>Many extensions include example files demonstrating their usage. These can be found in the <code>examples</code> directory within each extension's folder.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you'd like to contribute to this documentation or the extensions themselves, please visit our GitHub repository for more information.</p>"},{"location":"Archived/OMI_collider/","title":"OMI_collider","text":""},{"location":"Archived/OMI_collider/#contributors","title":"Contributors","text":"<ul> <li>Aaron Franke, The Mirror Megaverse Inc.</li> <li>Robert Long, The Matrix.org Foundation</li> <li>Mauve Signweaver, Mauve Software Inc.</li> </ul>"},{"location":"Archived/OMI_collider/#status","title":"Status","text":"<p>Open Metaverse Interoperability Group Stage 2 Proposal</p>"},{"location":"Archived/OMI_collider/#dependencies","title":"Dependencies","text":"<p>Written against the glTF 2.0 spec.</p> <p>Can be optionally used together with the <code>OMI_physics_body</code> spec.</p>"},{"location":"Archived/OMI_collider/#overview","title":"Overview","text":"<p>Colliders can be added to glTF nodes along with information about the \"type\" of collider it is representing.</p> <p>This extension allows specifying shapes to be used in glTF scenes for collision or triggers. Shapes should be specified on their own glTF nodes.</p> <p>This extension does not describe what colliders should do within a scene, aside from whether they are a trigger or not. For a more thorough physics body specification, you need to also use the <code>OMI_physics_body</code> extension, and add <code>OMI_collider</code> nodes as children of the physics body. Multiple <code>OMI_collider</code> siblings with the same <code>isTrigger</code> setting may be treated as a single \"compound collider\" in game engines that support them.</p>"},{"location":"Archived/OMI_collider/#example","title":"Example:","text":"<p>This example defines a single box collider with a size of 1 meter in all dimensions:</p> <pre><code>{\n    \"asset\": {\n        \"version\": \"2.0\"\n    },\n    \"extensions\": {\n        \"OMI_collider\": {\n            \"colliders\": [\n                {\n                    \"size\": [1, 1, 1],\n                    \"type\": \"box\"\n                }\n            ]\n        }\n    },\n    \"extensionsUsed\": [\n        \"OMI_collider\"\n    ],\n    \"nodes\": [\n        {\n            \"extensions\": {\n                \"OMI_collider\": {\n                    \"collider\": 0\n                }\n            },\n            \"name\": \"BoxCollider\"\n        }\n    ],\n    \"scene\": 0,\n    \"scenes\": [\n        {\n            \"nodes\": [0]\n        }\n    ]\n}\n</code></pre> <p>More example assets can be found in the examples/ folder. All of these examples use <code>OMI_collider</code> and not <code>OMI_physics_body</code>.</p>"},{"location":"Archived/OMI_collider/#gltf-schema-updates","title":"glTF Schema Updates","text":"<p>This extension consists of three new data structures for defining colliders on the root glTF document and referencing them on a glTF node. The main data structure defines a collider shape and is what most of this document describes. The second data structure uses the key <code>\"OMI_collider\"</code> in the document-level <code>\"extensions\"</code> which contains a list of the main collider shape data structures. The third data structure uses the key <code>\"OMI_collider\"</code> in the node-level <code>\"extensions\"</code> which contains an index of the collider shape to use from the list document-level collider list.</p> <p>The extension must also be added to the glTF's <code>extensionsUsed</code> array and because it is optional, it does not need to be added to the <code>extensionsRequired</code> array.</p>"},{"location":"Archived/OMI_collider/#property-summary","title":"Property Summary","text":"<p>The rest of the document, including this summary, defines the properties for the main data structure.</p> Type Description Default value Valid on type <code>string</code> The type of the collider shape as a string. Required, no default Always valid isTrigger <code>boolean</code> If true, the shape is a trigger and is not solid to other objects. false Always valid size <code>number[3]</code> The size of the box shape in meters. [1.0, 1.0, 1.0] Box radius <code>number</code> The radius of the shape in meters. 0.5 Sphere, capsule, cylinder height <code>number</code> The height of the shape in meters. 2.0 Capsule, cylinder mesh <code>number</code> The index of the glTF mesh in the document to use as a trimesh shape. -1 Trimesh, hull"},{"location":"Archived/OMI_collider/#collider-types","title":"Collider Types","text":"<p>The <code>\"type\"</code> property is a lowercase string that defines what type of shape this collider is.</p> <p>The selection of shapes was carefully chosen with a balance of compatibility between major game engines and containing the most commonly used shapes for easy asset creation. Colliders inherit the transform of the glTF node they are attached to. This includes rotation and translation, however it is discouraged to scale collider nodes since this can cause problems in some physics engines.</p> <p>Here is a table listing the mapping between the <code>OMI_collider</code> type and the equivalent types in major game engines.</p> Shape Unity Unreal Godot Blender Bullet (Ammo, Panda3D, etc) Box Box Box BoxShape3D Box Box Shape Sphere Sphere Sphere SphereShape3D Sphere Sphere Shape Capsule Capsule Capsule CapsuleShape3D Capsule Capsule Shape Cylinder Approximation Approximation CylinderShape3D Cylinder Cylinder Shape Hull Mesh (Convex) Convex ConvexPolygonShape3D Convex Hull Convex Shape Trimesh Mesh Mesh ConcavePolygonShape3D Mesh Mesh Shape"},{"location":"Archived/OMI_collider/#box","title":"Box","text":"<p>Box shapes describe a cube or cuboid shape. They have <code>size</code> property which is an array of 3 numbers that describes the width, height, and depth. If the <code>size</code> property is omitted, the default size is <code>[1, 1, 1]</code>, representing a cube with a volume of one cubic meter, edges/diameters one meter long, and extents/radius of half a meter. The position of the glTF node is the center of the box shape.</p>"},{"location":"Archived/OMI_collider/#sphere","title":"Sphere","text":"<p>Sphere shapes describe a uniform \"ball\" shape. They have a <code>radius</code> property which is a single number. If the <code>radius</code> property is omitted, the default radius is <code>0.5</code>, representing a sphere with a radius of half a meter, a diameter of one meter. The position of the glTF node is the center of the sphere shape.</p>"},{"location":"Archived/OMI_collider/#capsule","title":"Capsule","text":"<p>Capsule shapes describe a \"pill\" shape. They have a <code>radius</code> and <code>height</code> property. The height is aligned with the node's local vertical axis. If you wish to align it along a different axis, rotate the glTF node. If the <code>radius</code> property is omitted, the default radius is <code>0.5</code>, and if the <code>height</code> property is omitted, the default height is <code>2</code>. The height describes the total height from bottom to top. The height of the capsule must be at least twice as much as the radius. The \"mid-height\" between the centers of each spherical cap end can be found with <code>height - radius * 2</code>.</p>"},{"location":"Archived/OMI_collider/#cylinder","title":"Cylinder","text":"<p>Cylinder shapes describe a \"tall circle\" shape. They are similar in structure to capsules, they have a <code>radius</code> and <code>height</code> property. The height is aligned with the node's local vertical axis. If you wish to align it along a different axis, rotate the glTF node. If the <code>radius</code> property is omitted, the default radius is <code>0.5</code>, and if the <code>height</code> property is omitted, the default height is <code>2</code>.</p> <p>The use of cylinder is discouraged if another shape would work well in its place. Cylinders are harder to calculate than boxes, spheres, and capsules. Not all game engines support cylinder shapes. Engines that do not support cylinder shapes should use an approximation, such as a convex hull roughly shaped like a cylinder. Cylinders over twice as tall as they are wide can use another approximation: a convex hull combined with an embedded capsule (to allow for smooth rolling), by copying the cylinder's values into a new capsule shape.</p>"},{"location":"Archived/OMI_collider/#hull","title":"Hull","text":"<p>Hull shapes represent a convex hull. Being \"convex\" means that the shape cannot have any holes or divots. Hulls are defined with a <code>mesh</code> property with an index of a mesh in the glTF <code>meshes</code> array. The glTF mesh in the array MUST be a <code>trimesh</code> to work, and should be made of only one glTF mesh primitive (one surface). Valid hulls must contain at least one triangle, which becomes three points on the convex hull. Hulls are recommended to have at least four points so that they have 3D volume. The final hull shape should have no more than 255 points in total.</p> <p>Hulls can be used to represent complex convex shapes that are not easy to represent with other primitives. If a shape can be represented with a few primitives, prefer using those primitives instead of convex hulls. Hulls are much faster than trimesh shapes.</p>"},{"location":"Archived/OMI_collider/#trimesh","title":"Trimesh","text":"<p>Trimesh shapes represent a concave triangle mesh. They are defined with a <code>mesh</code> property with an index of a mesh in the glTF <code>meshes</code> array. The glTF mesh in the array MUST be a <code>trimesh</code> to work, and should be made of only one glTF mesh primitive (one surface). Valid trimesh shapes must contain at least one triangle.</p> <p>Avoid using a trimesh shape for most objects, they are the slowest shapes to calculate and have several limitations. Most physics engines do not support moving trimesh shapes or calculating collisions between multiple trimesh shapes. Trimesh shapes will not work reliably with <code>isTrigger</code> or with pushing objects out due to not having an \"interior\" space, they only have a surface. Trimesh shapes are typically used for complex level geometry (for example, things that you can go inside of). If your shape can be represented with a combination of simpler primitives, or a convex hull, or multiple convex hulls, prefer that instead.</p>"},{"location":"Archived/OMI_collider/#trigger","title":"Trigger","text":"<p>The <code>\"isTrigger\"</code> property defines if this shape is a trigger or collider. It is a boolean, either <code>true</code> or <code>false</code>. If omitted, the default value is <code>false</code>.</p> <p>Trigger shapes are not solid to other objects and will not collide with them. Triggers can generate events when another physics body \"enters\" them. For example, a \"goal\" area which triggers whenever a ball gets thrown into it. Which event gets triggered by a trigger shape is game-specific and not defined by <code>OMI_collider</code> (if nothing happens, that is also valid).</p>"},{"location":"Archived/OMI_collider/#json-schema","title":"JSON Schema","text":"<p>See schema/glTF.OMI_collider.collider.schema.json for the main collider schema, schema/glTF.OMI_collider.schema.json for the document-level list of colliders, and schema/node.OMI_collider.schema.json for the node-level collider selection.</p>"},{"location":"Archived/OMI_collider/#known-implementations","title":"Known Implementations","text":"<ul> <li>Godot Engine: https://github.com/godotengine/godot/pull/69266</li> <li>Third Room Unity Exporter: https://github.com/matrix-org/thirdroom-unity-exporter/blob/main/Runtime/Scripts/OMI_collider/OMI_ColliderExtension.cs</li> <li>Third Room glTF Transform: https://github.com/matrix-org/thirdroom/blob/main/src/asset-pipeline/extensions/OMIColliderExtension.ts</li> <li>Third Room glTF Loader: https://github.com/matrix-org/thirdroom/blob/main/src/engine/gltf/OMI_collider.ts</li> <li>Three Object Viewer WordPress Plugin: https://github.com/antpb/three-object-viewer/</li> </ul>"},{"location":"Archived/OMI_collider/#resources","title":"Resources:","text":"<ul> <li>Godot Shapes: https://docs.godotengine.org/en/latest/classes/class_shape3d.html</li> <li>Unity Colliders: https://docs.unity3d.com/Manual/CollidersOverview.html</li> <li>Unreal Engine Collision Shapes: https://docs.unrealengine.com/4.27/en-US/API/Runtime/PhysicsCore/FCollisionShape/</li> <li>Unreal Engine Mesh Collisions: https://docs.unrealengine.com/4.27/en-US/WorkingWithContent/Types/StaticMeshes/HowTo/SettingCollision/</li> <li>Blender Collisions: https://docs.blender.org/manual/en/latest/physics/rigid_body/properties/collisions.html</li> <li>Mozilla Hubs ammo-shape: https://github.com/MozillaReality/hubs-blender-exporter/blob/bb28096159e1049b6b80da00b1ae1534a6ca0855/default-config.json#L608</li> </ul>"},{"location":"KHR_audio_emitter/","title":"KHR_audio_emitter","text":""},{"location":"KHR_audio_emitter/#contributors","title":"Contributors","text":"<ul> <li>Robert Long, Element Inc.</li> <li>Anthony Burchell, Individual Contributor</li> <li>K. S. Ernest (iFire) Lee, Individual Contributor</li> <li>Michael Nisbet, Individual Contributor</li> <li>humbletim, Individual Contributor</li> <li>Norbert Nopper, UX3D @UX3DGpuSoftware</li> <li>Aaron Franke, The Mirror Megaverse Inc.</li> </ul>"},{"location":"KHR_audio_emitter/#status","title":"Status","text":"<p>Draft</p>"},{"location":"KHR_audio_emitter/#dependencies","title":"Dependencies","text":"<p>Written against the glTF 2.0 spec.</p>"},{"location":"KHR_audio_emitter/#overview","title":"Overview","text":"<p>This extension allows for the addition of spatialized and non-spatialized audio to glTF scenes.</p> <p>Audio emitter objects may be added to 3D nodes for positional audio or to the scene for environmental or ambient audio such as background music.</p>"},{"location":"KHR_audio_emitter/#example","title":"Example:","text":"<pre><code>{\n    \"extensions\": {\n        \"KHR_audio_emitter\": {\n            \"emitters\": [\n                {\n                    \"name\": \"Positional Emitter\",\n                    \"type\": \"positional\",\n                    \"gain\": 0.8,\n                    \"sources\": [0, 1],\n                    \"positional\": {\n                        \"shapeType\": \"omnidirectional\",\n                        \"distanceModel\": \"inverse\",\n                        \"maxDistance\": 10.0,\n                        \"refDistance\": 1.0,\n                        \"rolloffFactor\": 0.8\n                    }\n                },\n                {\n                    \"name\": \"Global Emitter\",\n                    \"type\": \"global\",\n                    \"gain\": 0.8,\n                    \"sources\": [1]\n                }\n            ],\n            \"sources\": [\n                {\n                    \"name\": \"Clip 1\",\n                    \"gain\": 0.6,\n                    \"autoPlay\": true,\n                    \"loop\": true,\n                    \"audio\": 0\n                },\n                {\n                    \"name\": \"Clip 2\",\n                    \"gain\": 0.6,\n                    \"autoPlay\": true,\n                    \"loop\": true,\n                    \"audio\": 1\n                }\n            ],\n            \"audio\": [\n                {\n                    \"uri\": \"audio1.mp3\"\n                },\n                {\n                    \"bufferView\": 0,\n                    \"mimeType\": \"audio/mpeg\"\n                }\n            ]\n        }\n    },\n    \"scenes\": [\n        {\n            \"name\": \"Default Scene\",\n            \"extensions\": {\n                \"KHR_audio_emitter\": {\n                    \"emitters\": [1]\n                }\n            }\n        }\n    ],\n    \"nodes\": [\n        {\n            \"name\": \"Duck\",\n            \"translation\": [1.0, 2.0, 3.0],\n            \"extensions\": {\n                \"KHR_audio_emitter\": {\n                    \"emitter\": 0\n                }\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"KHR_audio_emitter/#gltf-schema-updates","title":"glTF Schema Updates","text":"<p>This extension consists of three primary data structures: Audio Data, Audio Sources, and Audio Emitters. Data, sources and emitters are defined on an <code>KHR_audio_emitter</code> object added to the <code>extensions</code> object on the document root.</p> <p>The extension must be added to the file's <code>extensionsUsed</code> array and because it is optional, it does not need to be added to the <code>extensionsRequired</code> array.</p>"},{"location":"KHR_audio_emitter/#example_1","title":"Example:","text":"<pre><code>{\n    \"asset\": {\n        \"version\": \"2.0\"\n    },\n    \"extensionsUsed\": [\n        \"KHR_audio_emitter\"\n    ],\n    \"scenes\": [...],\n    \"nodes\": [...],\n    \"extensions\": {\n        \"KHR_audio_emitter\": {\n            \"audio\": [...],\n            \"sources\": [...],\n            \"emitters\": [...]\n        }\n    }\n}\n</code></pre>"},{"location":"KHR_audio_emitter/#audio-data","title":"Audio Data","text":"<p>Audio data objects define where audio data is located and what format the data is in. The data is either accessed via a bufferView or uri.</p> <p>When storing audio data in a buffer view, the <code>mimeType</code> field must be specified. The base specification supports <code>audio/mpeg</code> and <code>audio/wav</code> MIME types. These were chosen with consideration for the wide support for these types acrosss 3D engines and common use cases. Other supported audio formats may be added via extensions.</p> <p>Note that in tools that process glTF files, but do not implement the <code>KHR_audio_emitter</code> extension, external files referenced via the <code>uri</code> field may not be properly copied to their final destination or baked into the final binary glTF file. In these cases, using the <code>bufferView</code> property may be a better choice assuming the referenced <code>bufferView</code> index is not changed by the tool. The <code>uri</code> field might be a better choice when you want to be able to quickly change the referenced audio asset.</p>"},{"location":"KHR_audio_emitter/#buffer-view","title":"Buffer View","text":"<p>The <code>\"bufferView\"</code> property is the integer index of the bufferView that contains the audio data. If present, use this instead of the audio source's uri property.</p>"},{"location":"KHR_audio_emitter/#mime-type","title":"MIME Type","text":"<p>The <code>\"mimeType\"</code> property is a string that specifies the audio's MIME type. Required if <code>bufferView</code> is defined. Unless specified by another extension, the only supported mimeTypes are <code>audio/mpeg</code> and <code>audio/wav</code>.</p>"},{"location":"KHR_audio_emitter/#uri","title":"URI","text":"<p>The <code>\"uri\"</code> property is a string for the uri of the audio file. Relative paths are relative to the .gltf file.</p>"},{"location":"KHR_audio_emitter/#audio-sources","title":"Audio Sources","text":"<p>Audio sources reference audio data and define playback properties for it. Audio sources may be used by zero to many audio emitters.</p>"},{"location":"KHR_audio_emitter/#property-summary","title":"Property Summary","text":"Type Description Default value gain <code>number</code> Unitless linear multiplier against original audio file volume used for determining audio source loudness. 1.0 loop <code>boolean</code> Whether or not to loop the specified audio when finished. false autoPlay <code>boolean</code> Whether or not to play the specified audio when the glTF is loaded. false audio <code>number</code> The index of the audio data assigned to this clip. Required, no default"},{"location":"KHR_audio_emitter/#gain","title":"Gain","text":"<p>The <code>\"gain\"</code> property is a number that is a unitless linear multiplier against original audio file volume used for determining audio source loudness. If not specified, the audio source volume gain is <code>1.0</code>.</p> <p>This value is linear, a value of <code>0.0</code> is no volume, <code>0.5</code> is half volume, <code>1.0</code> is the original volume, <code>2.0</code> is double the volume, etc. The final volume of the audio is a combination of this value, the audio emitter's gain, and if the audio emitter is positional, the relative positions of the emitter and listener.</p>"},{"location":"KHR_audio_emitter/#loop","title":"Loop","text":"<p>The <code>\"loop\"</code> property is a boolean that specifies whether or not to loop the specified audio when finished. If <code>false</code> or not specified, the audio source does not loop.</p>"},{"location":"KHR_audio_emitter/#auto-play","title":"Auto Play","text":"<p>The <code>\"autoPlay\"</code> property is a boolean that specifies whether or not to play the specified audio when the glTF is loaded. If <code>false</code> or not specified, the audio source does not play automatically.</p>"},{"location":"KHR_audio_emitter/#audio","title":"Audio","text":"<p>The <code>\"audio\"</code> property is an integer index of the audio data in the \"audio\" array assigned to this audio source. This property is required.</p>"},{"location":"KHR_audio_emitter/#audio-emitter","title":"Audio Emitter","text":"<p>Audio emitters define how audio sources are played back. Emitter properties are defined at the document level and are references by nodes. Audio may be played globally or positionally. Positional audio has further properties that define how audio volume scales with distance and angle.</p>"},{"location":"KHR_audio_emitter/#property-summary_1","title":"Property Summary","text":"Type Description Default value type <code>string</code> The emitter type of this audio emitter: <code>global</code> or <code>positional</code>. Required, no default gain <code>number</code> Unitless linear multiplier against audio source volume used for determining audio emitter loudness. 1.0 sources <code>number[]</code> An array of audio source indices used by the audio emitter. This array may be empty. [] positional <code>object</code> A sub-JSON containing the positional audio emitter properties. {}"},{"location":"KHR_audio_emitter/#type","title":"Type","text":"<p>The <code>\"type\"</code> property is a string that specifies the audio emitter type. This property is required.</p> <ul> <li><code>global</code> Global audio emitters are not affected by the position of audio listeners. All <code>positional</code> properties may not be defined on global audio emitters.</li> <li><code>positional</code> Positional audio emitters play audio at a position in the scene. The properties are defined in the <code>positional</code> object. Using sound cones, the orientation is <code>-Z</code> having the same emission direction as <code>KHR_lights_punctual</code> and glTF cameras.</li> </ul>"},{"location":"KHR_audio_emitter/#gain_1","title":"Gain","text":"<p>The <code>\"gain\"</code> property is a number that is a unitless linear multiplier against audio source volume used for determining audio emitter loudness. If not specified, the audio emitter volume gain is <code>1.0</code>.</p> <p>This value is linear, a value of <code>0.0</code> is no volume, <code>0.5</code> is half volume, <code>1.0</code> is the original volume, <code>2.0</code> is double the volume, etc. The final volume of the audio is a combination of this value, the audio source's gain, and if the audio emitter is positional, the relative positions of the emitter and listener.</p>"},{"location":"KHR_audio_emitter/#sources","title":"Sources","text":"<p>The <code>\"sources\"</code> property is an array of integer indices of audio sources in the \"sources\" array used by the audio emitter. This array may be empty. If empty or not specified, this emitter can be used to define how audio should emit from a node, but not which audio source to play.</p>"},{"location":"KHR_audio_emitter/#positional","title":"Positional","text":"<p>The <code>\"positional\"</code> property is a sub-JSON object containing the positional audio emitter properties. This may only be defined if <code>type</code> is set to <code>positional</code>.</p>"},{"location":"KHR_audio_emitter/#positional-audio-emitter-properties","title":"Positional Audio Emitter Properties","text":"<p>When the audio emitter type is set to <code>positional</code>, additional properties may be defined on the <code>positional</code> object.</p>"},{"location":"KHR_audio_emitter/#property-summary_2","title":"Property Summary","text":"Type Description Default value shapeType <code>string</code> The shape of the audio emitter. May be <code>omnidirectional</code>, <code>cone</code>, or a value specified by another extension. <code>\"omnidirectional\"</code> coneInnerAngle <code>number</code> The anglular diameter of a cone inside of which there will be no angular volume reduction. 6.2831853... (\u03c4 or 2\u03c0 rad, 360 deg) coneOuterAngle <code>number</code> The anglular diameter of a cone outside of which the volume will be reduced to a constant value of <code>coneOuterGain</code>. 6.2831853... (\u03c4 or 2\u03c0 rad, 360 deg) coneOuterGain <code>number</code> The linear volume gain of the audio emitter set when outside the cone defined by the <code>coneOuterAngle</code> property. 0.0 distanceModel <code>string</code> Specifies the distance model for the audio emitter. <code>\"inverse\"</code> maxDistance <code>number</code> The maximum distance between the emitter and listener, beyond which the audio cannot be heard. 0.0 refDistance <code>number</code> A reference distance for reducing volume as the emitter moves further from the listener. 1.0 rolloffFactor <code>number</code> Describes how quickly the volume is reduced as the emitter moves away from listener. 1.0"},{"location":"KHR_audio_emitter/#shape-type","title":"Shape Type","text":"<p>The <code>\"shapeType\"</code> property is a string that defines shape type of the audio emitter. May be <code>\"omnidirectional\"</code>, <code>\"cone\"</code>, or a value specified by another extension. If not specified, the default shape is <code>omnidirectional</code>.</p> <p>If the shape is <code>\"omnidirectional\"</code>, the <code>\"coneInnerAngle\"</code>, <code>\"coneOuterAngle\"</code>, and <code>\"coneOuterGain\"</code> properties are ignored.</p>"},{"location":"KHR_audio_emitter/#cone-inner-angle","title":"Cone Inner Angle","text":"<p>The <code>\"coneInnerAngle\"</code> property is a number that defines the angle, in radians, of a cone inside of which there will be no volume reduction. This angle represents the angular \"diameter\" of the cone, from side to side. If not specified, the angle of Tau radians (<code>6.283185307179586476925286766559</code> or 360 degrees) is used, which means the audio emits in all directions (not in a cone).</p>"},{"location":"KHR_audio_emitter/#cone-outer-angle","title":"Cone Outer Angle","text":"<p>The <code>\"coneOuterAngle\"</code> property is a number that defines the angle, in radians, of a cone outside of which the volume will be reduced to a constant value of <code>coneOuterGain</code>. This angle represents the angular \"diameter\" of the cone, from side to side. If not specified, the angle of Tau radians (<code>6.283185307179586476925286766559</code> or 360 degrees) is used, which means some audio will emit in all directions.</p>"},{"location":"KHR_audio_emitter/#cone-outer-gain","title":"Cone Outer Gain","text":"<p>The <code>\"coneOuterGain\"</code> property is a number that defines the linear volume gain of the audio emitter set when outside the cone defined by the <code>coneOuterAngle</code> property. It is a linear value (not dB). If not specified, the cone outer gain is <code>0.0</code>, meaning the audio will be silent outside of the cone.</p>"},{"location":"KHR_audio_emitter/#distance-model","title":"Distance Model","text":"<p>The <code>\"distanceModel\"</code> property is a string that specifies the distance model for the audio emitter.</p> <ul> <li><code>linear</code> A linear distance model calculating the gain induced by the distance according to:     <code>1.0 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance)</code></li> <li><code>inverse</code> (default) An inverse distance model calculating the gain induced by the distance according to:     <code>refDistance / (refDistance + rolloffFactor * (Math.max(distance, refDistance) - refDistance))</code></li> <li><code>exponential</code> An exponential distance model calculating the gain induced by the distance according to:     <code>pow((Math.max(distance, refDistance) / refDistance, -rolloffFactor))</code></li> </ul>"},{"location":"KHR_audio_emitter/#max-distance","title":"Max Distance","text":"<p>The <code>\"maxDistance\"</code> property is a number that defines the maximum distance between the emitter and listener, after which the volume will not be reduced any further. If zero or not specified, the audio emitter does not have a maximum distance, and it can be heard from any distance.</p> <p>For the linear distance model, the max distance must be greater than the ref distance. For all distance models, max distance cannot be a negative number.</p>"},{"location":"KHR_audio_emitter/#ref-distance","title":"Ref Distance","text":"<p>The <code>\"refDistance\"</code> property is a number that defines a reference distance for reducing volume as the emitter moves further from the listener. For distances less than this, the volume is not reduced. This value cannot be zero or a negative number. If not specified, the default value is <code>1.0</code>.</p>"},{"location":"KHR_audio_emitter/#rolloff-factor","title":"Rolloff Factor","text":"<p>The <code>\"rolloffFactor\"</code> property is a number that describes how quickly the volume is reduced as the emitter moves away from listener. When distanceModel is set to linear, the maximum value is <code>1.0</code>. Otherwise, there is no upper limit to the rolloff factor. If not specified, the default value is <code>1.0</code>.</p>"},{"location":"KHR_audio_emitter/#using-audio-emitters","title":"Using Audio Emitters","text":"<p>Audio emitters of type <code>global</code> may be added to scenes using the following syntax:</p> <pre><code>{\n    \"scenes\": [\n        {\n            \"extensions\": {\n                \"KHR_audio_emitter\": {\n                    \"emitters\": [1, 3]\n                }\n            }\n        }\n    ]\n}\n</code></pre> <p>Audio emitters of type <code>global</code> may be added to nodes using the following syntax:</p> <pre><code>{\n    \"nodes\": [\n        {\n            \"extensions\": {\n                \"KHR_audio_emitter\": {\n                    \"emitter\": 1\n                }\n            }\n        }\n    ]\n}\n</code></pre> <p>Audio emitters of type <code>positional</code> may be added to nodes using the following syntax:</p> <pre><code>{\n    \"nodes\": [\n        {\n            \"extensions\": {\n                \"KHR_audio_emitter\": {\n                    \"emitter\": 0\n                }\n            }\n        }\n    ]\n}\n</code></pre> <p>Note that multiple global audio emitters are allowed on the scene, but only a single audio emitter may be added to a node.</p>"},{"location":"KHR_audio_emitter/#audio-rolloff-formula","title":"Audio Rolloff Formula","text":"<p>The Audio Rolloff range is <code>(0.0, +\u221e)</code>. The default is <code>1.0</code>.</p> <p>The rolloff formula is dependant on the distance model defined. The available distance models are <code>linear</code>, <code>inverse</code>, and <code>exponential</code>.</p> <ul> <li>linear formula: <code>1.0 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance)</code></li> <li>inverse formula: <code>refDistance / (refDistance + rolloffFactor * (Math.max(distance, refDistance) - refDistance))</code></li> <li>exponential formula: <code>pow((Math.max(distance, refDistance) / refDistance, -rolloffFactor))</code></li> </ul>"},{"location":"KHR_audio_emitter/#audio-gain-units","title":"Audio Gain Units","text":"<p>The gain unit range is <code>(0.0, +\u221e)</code>. The default is <code>1.0</code>.</p> <ul> <li>gain formula: <code>originalVolume * gain</code></li> </ul>"},{"location":"KHR_audio_emitter/#audio-cone-vizualized","title":"Audio Cone Vizualized","text":"<p>Figure 1. A modified graphic based on the W3C Web Audio API Audio cone Figure</p> <p>The cone properties relate to the <code>PannerNode</code> interface and determine the amount of volume relative to a listeners position within the defined cone area.</p> <p>The gain relative to cone properties is determined in a similar way as described in the web audio api with the difference that this audio emitter extension uses radians in place of degrees. Cone Gain Algorithm Example</p>"},{"location":"KHR_audio_emitter/#unit-for-angles","title":"Unit for Angles","text":"<p>Radians are used for angles matching glTF2.</p>"},{"location":"KHR_audio_emitter/#json-schema","title":"JSON Schema","text":"<p>See glTF.KHR_audio_emitter.schema.json for the main document-level schema.</p>"},{"location":"KHR_audio_emitter/#known-implementations","title":"Known Implementations","text":"<ul> <li>Third Room - https://github.com/thirdroom/thirdroom</li> <li>Three Object Viewer (WordPress Plugin) - https://wordpress.org/plugins/three-object-viewer/</li> <li>UX3D Experimental C++ implementation - https://github.com/ux3d/OMI</li> </ul>"},{"location":"KHR_audio_emitter/#resources","title":"Resources","text":"<p>Prior Art:</p> <ul> <li>W3C Web Audio API</li> <li>MSFT_audio_emitter</li> <li>MOZ_hubs_components Audio</li> </ul>"},{"location":"OMI_audio_ogg_vorbis/","title":"OMI_audio_ogg_vorbis","text":""},{"location":"OMI_audio_ogg_vorbis/#contributors","title":"Contributors","text":"<ul> <li>Aaron Franke, Godot Engine.</li> </ul>"},{"location":"OMI_audio_ogg_vorbis/#status","title":"Status","text":"<p>Open Metaverse Interoperability Group Stage 1 Proposal</p>"},{"location":"OMI_audio_ogg_vorbis/#dependencies","title":"Dependencies","text":"<p>Written against the glTF 2.0 spec.</p>"},{"location":"OMI_audio_ogg_vorbis/#overview","title":"Overview","text":"<p>This extension allows glTF models to use Ogg Vorbis as a valid audio data format. A client that does not implement this extension can ignore the provided Ogg Vorbis audio data and continue to rely on the MP3 audio available in the base KHR_audio_emitter specification, if any. Defining fallback audio data is optional. The best practices section describes the intended use case of this extension and the expected behavior when using it without fallback audio data.</p> <p>Ogg Vorbis is a free and open-source lossy audio compression format. It is widely used in video games and other applications that require high-quality audio with a small file size. It has similar use cases to MP3, but is more efficient, with a higher quality for the same file size, or a smaller file size for the same quality.</p>"},{"location":"OMI_audio_ogg_vorbis/#gltf-schema-updates","title":"glTF Schema Updates","text":"<p>The <code>OMI_audio_ogg_vorbis</code> extension can be added to the extensions of an object in the <code>\"sources\"</code> array inside of <code>KHR_audio_emitter</code>. and specifies an <code>audio</code> property that points to the index of an object in the <code>\"audio\"</code> array which in turn points to the Ogg Vorbis audio data.</p> <p>The following glTF will load <code>music.ogg</code> in clients that support this extension, and otherwise fall back to <code>music.mp3</code>. Note that this example excludes other properties typically found on an item in <code>\"sources\"</code>, such as the name or gain.</p> <pre><code>\"KHR_audio_emitter\": {\n    \"sources\": [\n        {\n            \"audio\": 0,\n            \"extensions\": {\n                \"OMI_audio_ogg_vorbis\": {\n                    \"audio\": 1\n                }\n            }\n        }\n    ],\n    \"audio\": [\n        {\n            \"uri\": \"music.mp3\"\n        },\n        {\n            \"uri\": \"music.ogg\"\n        }\n    ]\n}\n</code></pre> <p>When defined with a <code>uri</code> and no <code>mimeType</code>, the file extension of the audio data MUST be <code>.ogg</code>. The <code>.oga</code> file extension MUST NOT be used for Vorbis audio data. Although most audio in the Ogg container shares the same MIME type, Vorbis and Speex have been grandfathered in to use <code>.ogg</code> as the file extension, while other audio codecs in the Ogg container may use <code>.oga</code> or another file extension.</p> <p>Audio data can also be stored in a buffer, such as in the glTF Binary (.glb) format. When stored here, the item in the \"audio\" MUST have a <code>mimeType</code> set to <code>audio/ogg</code>.</p> <pre><code>\"KHR_audio_emitter\": {\n    \"sources\": [\n        {\n            \"audio\": 0,\n            \"extensions\": {\n                \"OMI_audio_ogg_vorbis\": {\n                    \"audio\": 1\n                }\n            }\n        }\n    ],\n    \"audio\": [\n        {\n            \"mimeType\": \"audio/mpeg\",\n            \"bufferView\": 1\n        },\n        {\n            \"mimeType\": \"audio/ogg\",\n            \"bufferView\": 2\n        }\n    ]\n}\n</code></pre>"},{"location":"OMI_audio_ogg_vorbis/#json-schema","title":"JSON Schema","text":"<p>KHR_audio_emitter.source.OMI_audio_ogg_vorbis.schema.json</p>"},{"location":"OMI_audio_ogg_vorbis/#best-practices","title":"Best Practices","text":"<p>Ogg Vorbis has similar use cases to MP3. Both are lossy audio compression formats that are widely supported. Ogg Vorbis should be preferred to MP3 when delivering audio data to clients that support loading Ogg Vorbis audio data from <code>OMI_audio_ogg_vorbis</code>.</p> <p>Since Ogg Vorbis is not a part of the base KHR_audio_emitter spec, it is recommended to provide an MP3 fallback for clients that do not support this extension. The fallback audio data would typically be of lower quality than the corresponding Ogg Vorbis audio data, such that the total file size of both files is lower than the full quality audio saved as MP3, otherwise it would defeat the purpose of using Ogg Vorbis to reduce file size.</p> <p>When fallback audio data is defined, this extension should not be present in <code>extensionsRequired</code>. This will allow clients that support <code>KHR_audio_emitter</code> but not <code>OMI_audio_ogg_vorbis</code> to play the fallback audio data.</p>"},{"location":"OMI_audio_ogg_vorbis/#using-without-a-fallback","title":"Using Without a Fallback","text":"<p>To use Ogg Vorbis audio data without a fallback, define <code>OMI_audio_ogg_vorbis</code> in <code>extensionsUsed</code>, and if <code>KHR_audio_emitter</code> is a required extension, define <code>OMI_audio_ogg_vorbis</code> in <code>extensionsRequired</code> as well. The item in the <code>\"sources\"</code> array will then not have an <code>audio</code> property, and instead have an <code>extensions</code> property to define the audio data as shown below.</p> <pre><code>\"KHR_audio_emitter\": {\n    \"sources\": [\n        {\n            \"extensions\": {\n                \"OMI_audio_ogg_vorbis\": {\n                    \"audio\": 0\n                }\n            }\n        }\n    ],\n    \"audio\": [\n        {\n            \"uri\": \"music.ogg\"\n        }\n    ]\n}\n</code></pre> <p>If a glTF contains an audio source using Ogg Vorbis audio with no fallback audio data, and <code>KHR_audio_emitter</code> is a required extension, then <code>OMI_audio_ogg_vorbis</code> should be added to the <code>extensionsRequired</code> array, such that clients that do not support Ogg Vorbis will not attempt to load the file. This ensures that glTF files which require audio playback will also require the ability to load Ogg Vorbis audio data to be played.</p> <p>If a glTF contains an audio source using Ogg Vorbis audio with no fallback audio data, and <code>KHR_audio_emitter</code> is not a required extension, then do not add <code>OMI_audio_ogg_vorbis</code> to <code>extensionsRequired</code>. Clients supporting <code>KHR_audio_emitter</code> but not <code>OMI_audio_ogg_vorbis</code> will consider the lack of <code>\"audio\"</code> in a <code>KHR_audio_emitter</code> source to be an error, and either will not be able to play audio from that source, or will not load the <code>KHR_audio_emitter</code> extension.</p>"},{"location":"OMI_audio_ogg_vorbis/#json-schema_1","title":"JSON Schema","text":"<p>See schema/glTF.KHR_audio_emitter.source.OMI_audio_ogg_vorbis.schema.json for the schema.</p>"},{"location":"OMI_audio_ogg_vorbis/#known-implementations","title":"Known Implementations","text":"<p>None</p>"},{"location":"OMI_audio_ogg_vorbis/#resources","title":"Resources","text":"<ul> <li>https://wiki.xiph.org/Vorbis</li> <li>https://wiki.xiph.org/MIME_Types_and_File_Extensions</li> </ul>"},{"location":"OMI_audio_opus/","title":"OMI_audio_opus","text":""},{"location":"OMI_audio_opus/#contributors","title":"Contributors","text":"<ul> <li>Aaron Franke, Godot Engine.</li> </ul>"},{"location":"OMI_audio_opus/#status","title":"Status","text":"<p>Open Metaverse Interoperability Group Stage 1 Proposal</p>"},{"location":"OMI_audio_opus/#dependencies","title":"Dependencies","text":"<p>Written against the glTF 2.0 spec.</p>"},{"location":"OMI_audio_opus/#overview","title":"Overview","text":"<p>This extension allows glTF models to use Opus as a valid audio codec. A client that does not implement this extension can ignore the provided Opus audio data and continue to rely on the MP3 audio available in the base KHR_audio_emitter specification, if any. Defining fallback audio data is optional. The best practices section describes the intended use case of this extension and the expected behavior when using it without fallback audio data.</p> <p>Opus codec audio is a free and open source lossy audio codec. It is widely used in modern websites and other Internet applications, but does not have widespread support in popular game engines. It is proposed as an IETF standard as defined by IETF RFC 6716. Opus superior format to MP3 and Ogg Vorbis, and it is suitable for many use cases traditionally suitable to WAV audio. Opus is a lossy audio codec that is more efficient than MP3 and Ogg Vorbis, with a higher quality for the same file size, or a smaller file size for the same quality.</p> <p>The <code>OMI_audio_opus</code> extension allows the Opus audio data to be stored in either the Ogg container format or the WebM container format. This is done to minimize friction depending on the desired target platform. The Ogg container format is the de facto file format for Opus, it uses the <code>.opus</code> file extension and the <code>audio/opus</code> MIME type. The WebM container format is more commonly supported in web browsers such as Safari, it uses the <code>.webm</code> file extension and the <code>audio/webm</code> MIME type (or <code>video/webm</code> if the file contains video data, which is expected to be ignored by audio emitters). Implementations should be able to handle both formats, but may more efficiently support one format over the other. For example, in a web game targeting Safari, its own assets should be in the WebM container format, while if that same game encounters a user-provided glTF asset using Ogg Opus audio, the game may need to convert the audio to WebM Opus before playing it in Safari. The same may happen in reverse, if an app only supports Ogg Opus, it should prefer Ogg Opus for its own assets, and may need to convert WebM Opus to Ogg Opus before playing it. Additionally, WebM allows for videos, which allows the audio from a video file to be used in an audio emitter, while the video data may be used by another extension.</p>"},{"location":"OMI_audio_opus/#gltf-schema-updates","title":"glTF Schema Updates","text":"<p>The <code>OMI_audio_opus</code> extension can be added to the extensions of an object in the <code>\"sources\"</code> array inside of <code>KHR_audio_emitter</code>. and specifies an <code>audio</code> property that points to the index of an object in the <code>\"audio\"</code> array which in turn points to the Opus audio data.</p> <p>The following glTF will load <code>music.opus</code> in clients that support this extension, and otherwise fall back to <code>music.mp3</code>. Note that this example excludes other properties typically found on an item in <code>\"sources\"</code>, such as the name or gain.</p> <pre><code>\"KHR_audio_emitter\": {\n    \"sources\": [\n        {\n            \"audio\": 0,\n            \"extensions\": {\n                \"OMI_audio_opus\": {\n                    \"audio\": 1\n                }\n            }\n        }\n    ],\n    \"audio\": [\n        {\n            \"uri\": \"music.mp3\"\n        },\n        {\n            \"uri\": \"music.opus\"\n        }\n    ]\n}\n</code></pre> <p>When defined with a <code>uri</code> and no <code>mimeType</code>, the file extension of the audio data MUST be <code>.opus</code> when using the Ogg container format, or MUST be <code>.webm</code> when using the WebM container format. The <code>.oga</code> or <code>.ogg</code> file extensions MUST NOT be used for Opus codec audio data. Although most audio in the Ogg container shares the same MIME type, Opus uses <code>.opus</code> as the file extension, while other audio codecs in the Ogg container may use <code>.oga</code> or <code>.ogg</code> or another file extension.</p> <p>Audio data can also be stored in a buffer, such as in the glTF Binary (.glb) format. When stored here, the item in the \"audio\" MUST have a <code>mimeType</code> set to <code>audio/opus</code> when using the Ogg container format (see proposed IETF RFC 7587 for IANA), or <code>audio/webm</code> or <code>video/webm</code> when using the WebM container format. If a WebM contains only audio data, then <code>audio/webm</code> should be used. If a WebM contains video data, then <code>video/webm</code> should be used, and the video data is expected to be ignored when playing the audio from a <code>KHR_audio_emitter</code> source extended with <code>OMI_audio_opus</code> with this data.</p> <pre><code>\"KHR_audio_emitter\": {\n    \"sources\": [\n        {\n            \"audio\": 0,\n            \"extensions\": {\n                \"OMI_audio_opus\": {\n                    \"audio\": 1\n                }\n            }\n        }\n    ],\n    \"audio\": [\n        {\n            \"mimeType\": \"audio/mpeg\",\n            \"bufferView\": 1\n        },\n        {\n            \"mimeType\": \"audio/opus\",\n            \"bufferView\": 2\n        }\n    ]\n}\n</code></pre>"},{"location":"OMI_audio_opus/#json-schema","title":"JSON Schema","text":"<p>KHR_audio_emitter.source.OMI_audio_opus.schema.json</p>"},{"location":"OMI_audio_opus/#best-practices","title":"Best Practices","text":"<p>Opus codec audio is a superior format to MP3 and Ogg Vorbis for their intended use cases, and it is suitable for many use cases traditionally suitable to WAV audio. Opus is a lossy audio codec that is more efficient than MP3 and Ogg Vorbis, with a higher quality for the same file size, or a smaller file size for the same quality.</p> <p>Opus is designed to be used either for long-term audio storage or streaming audio over the internet. Opus has a low decode time, with a low latency, making it suitable for time-sensitive audio playback such as short sound effects in video games, therefore it can be used in place of WAV audio when lossy audio is acceptable. See the Wikipedia chart comparing Opus to other audio codecs.</p> <p>If making a comparison to image formats, Opus is to audio as WebP is to images. It is a modern, efficient, and high-quality format that is superior to older formats, but has less support in popular software.</p> <p>Since Opus is not a part of the base KHR_audio_emitter spec, it is recommended to provide an MP3 or WAV fallback for clients that do not support this extension. Prefer using an MP3 fallback for music or a WAV fallback for short sound effects. The fallback audio data would typically be of lower quality than the corresponding Opus audio data, such that the total file size of both files is lower than the full quality audio saved as MP3 or WAV, otherwise it would defeat the purpose of using Opus to reduce file size.</p> <p>When fallback audio data is defined, this extension should not be present in <code>extensionsRequired</code>. This will allow clients that support <code>KHR_audio_emitter</code> but not <code>OMI_audio_opus</code> to play the fallback audio data.</p>"},{"location":"OMI_audio_opus/#using-without-a-fallback","title":"Using Without a Fallback","text":"<p>To use Opus audio data without a fallback, define <code>OMI_audio_opus</code> in <code>extensionsUsed</code>, and if <code>KHR_audio_emitter</code> is a required extension, define <code>OMI_audio_opus</code> in <code>extensionsRequired</code> as well. The item in the <code>\"sources\"</code> array will then not have an <code>audio</code> property, and instead have an <code>extensions</code> property to define the audio data as shown below.</p> <pre><code>\"KHR_audio_emitter\": {\n    \"sources\": [\n        {\n            \"extensions\": {\n                \"OMI_audio_opus\": {\n                    \"audio\": 0\n                }\n            }\n        }\n    ],\n    \"audio\": [\n        {\n            \"uri\": \"music.opus\"\n        }\n    ]\n}\n</code></pre> <p>If a glTF contains an audio source using Opus audio with no fallback audio data, and <code>KHR_audio_emitter</code> is a required extension, then <code>OMI_audio_opus</code> should be added to the <code>extensionsRequired</code> array, such that clients that do not support Opus will not attempt to load the file. This ensures that glTF files which require audio playback will also require the ability to load Opus audio data to be played.</p> <p>If a glTF contains an audio source using Opus audio with no fallback audio data, and <code>KHR_audio_emitter</code> is not a required extension, then do not add <code>OMI_audio_opus</code> to <code>extensionsRequired</code>. Clients supporting <code>KHR_audio_emitter</code> but not <code>OMI_audio_opus</code> will consider the lack of <code>\"audio\"</code> in a <code>KHR_audio_emitter</code> source to be an error, and either will not be able to play audio from that source, or will not load the <code>KHR_audio_emitter</code> extension.</p>"},{"location":"OMI_audio_opus/#json-schema_1","title":"JSON Schema","text":"<p>See schema/glTF.KHR_audio_emitter.source.OMI_audio_opus.schema.json for the schema.</p>"},{"location":"OMI_audio_opus/#known-implementations","title":"Known Implementations","text":"<p>None</p>"},{"location":"OMI_audio_opus/#resources","title":"Resources","text":"<ul> <li>https://wiki.xiph.org/OpusFAQ</li> <li>https://datatracker.ietf.org/doc/html/rfc6716</li> <li>https://datatracker.ietf.org/doc/html/rfc7587#section-6.1</li> <li>https://commons.wikimedia.org/wiki/File:Opus_bitrate%2Blatency_comparison.png</li> <li>https://www.webmproject.org/docs/container/</li> </ul>"},{"location":"OMI_link/","title":"OMI_link","text":""},{"location":"OMI_link/#contributors","title":"Contributors","text":"<ul> <li>OMI glTF Extensions Group</li> <li>Robert Long, The Matrix.org Foundation</li> <li>Anthony Burchell, Individual Contributor</li> </ul>"},{"location":"OMI_link/#status","title":"Status","text":"<p>Draft Specification</p> <p>Open Metaverse Interoperability Group Stage 1 Proposal</p>"},{"location":"OMI_link/#dependencies","title":"Dependencies","text":"<p>Written against the glTF 2.0 spec.</p> <p>Optionally depends on the <code>OMI_physics_body</code> spec for triggers.</p>"},{"location":"OMI_link/#overview","title":"Overview","text":"<p>This extension allows for objects to add world traversal behavior in the form of links. This specification does not contain any definitions in how the link data is used and it is up to the client builder to decide how the link is activated.</p> <p>In addition to being defined independently, the <code>OMI_link</code> extension can be defined on an <code>OMI_physics_body</code> node with the type set to trigger. When <code>OMI_link</code> is on a trigger, the trigger should be treated as an activator for the link, such that a player activating that trigger should cause that player to activate the link.</p> <p>Clients may choose to have application-specific behaviors for URIs otherwise the default platform / browser URI handler should be used. Applications should perform any necessary URI security checks and may decide to present a dialog to inform the user of how the URI is handled.</p>"},{"location":"OMI_link/#example","title":"Example:","text":"<pre><code>{\n    \"scenes\": [\n        {\n            \"name\": \"Default Scene\",\n            \"nodes\": [0]\n        }\n    ],\n    \"nodes\": [\n        {\n            \"name\": \"OMI Group meetup space\",\n            \"translation\": [1.0, 2.0, 3.0],\n            \"extensions\": {\n                \"OMI_link\": {\n                    \"title\": \"Meetup World\",\n                    \"uri\": \"https://omigroup.org/worlds/meetup\"\n                },\n                \"OMI_physics_body\": {\n                    \"trigger\": {}\n                }\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"OMI_link/#gltf-schema-updates","title":"glTF Schema Updates","text":""},{"location":"OMI_link/#uri","title":"<code>uri</code>","text":"<p>Must be a valid uri, relative path, or fragment.</p> <p>Valid <code>uri</code> field values:</p> <pre><code>https://omigroup.org/worlds/meetup\nhttps://omigroup.org/worlds/meetup#portal1\nhttps://omigroup.org/worlds/meetup?autojoin=true#portal1\nvrchat://launch?id=wrld_hjdksahgklfshjfgjklsd\n./breakoutroom1\n#portal1\n</code></pre>"},{"location":"OMI_link/#title","title":"<code>title</code>","text":"<p>Optional field that describes the destination of the uri. Implementations can show this title if it exists or fallback to showing the uri.</p>"},{"location":"OMI_link/#json-schema","title":"JSON Schema","text":"<p>TODO</p>"},{"location":"OMI_link/#known-implementations","title":"Known Implementations","text":"<p>Interested Implementations: * Third Room - https://github.com/thirdroom/thirdroom * Three Object Viewer (WordPress Plugin) - https://wordpress.org/plugins/three-object-viewer/</p>"},{"location":"OMI_link/#resources","title":"Resources","text":"<p>TODO</p>"},{"location":"OMI_link/#prior-art","title":"Prior Art","text":"<ul> <li>Third Room - https://github.com/matrix-org/thirdroom-unity-exporter/tree/main/Runtime/Scripts/MX_portal</li> </ul>"},{"location":"OMI_personality/","title":"OMI_personality","text":""},{"location":"OMI_personality/#contributors","title":"Contributors","text":"<p>Anthony Burchell, Individual Contributor</p>"},{"location":"OMI_personality/#status","title":"Status","text":"<p>Draft Specification</p> <p>Open Metaverse interoperability Group Stage 1 proposal</p>"},{"location":"OMI_personality/#dependencies","title":"Dependencies","text":"<p>Written against the glTF 2.0 spec.</p>"},{"location":"OMI_personality/#overview","title":"Overview","text":"<p>The OMI_personality extension allows you to specify a personality for a glTF node representing a entity. This extension can be used in virtual worlds, where characters can have unique personalities, and interactions with them can be enhanced by providing additional information about their behavior and dialogue.</p>"},{"location":"OMI_personality/#example","title":"Example","text":"<p>To use the \"OMI_personality\" extension, you must first specify it in the extensionsUsed property of your glTF file.</p> <pre><code>{\n    \"extensionsUsed\": [\"OMI_personality\"]\n}\n</code></pre> <p>Next, apply the extension to a child node of the glTF file. The node's position and rotation data can be used to determine the location of the spawn point in the scene.</p> <pre><code>{\n    \"nodes\": [\n        {\n            \"name\": \"cat\",\n            \"extensions\": {\n                \"OMI_personality\": {\n                    \"agent\": \"cat\",\n                    \"personality\": \"#agent has a cheerful personality.\",\n                    \"defaultMessage\": \"nya nya!\"\n                }\n            }\n        }\n    ]\n}\n</code></pre> <p>In the example above, the \"OMI_personality\" extension is applied to a node named \"cat\". The agent property is used to specify the type of agent associated with the node, in this case, it's a cat. The personality property describes the agent's personality, and the defaultMessage property is the message that the agent will send as a default.</p>"},{"location":"OMI_personality/#properties","title":"Properties","text":"<p>The <code>defaultMessage</code> parameter is optional. The <code>agent</code> and <code>personality</code> options are required and provide context about the avatars name and default personality description.</p> Type Description agent <code>string</code> The name of the agent or NPC. personality <code>string</code> A default description of the personality of the agent allowing clients to inject that context into language model logic. defaultMessage <code>string</code> A default message for this agent to initialize with."},{"location":"OMI_personality/#json-schema","title":"JSON Schema","text":"<p>The OMI_personality extension is defined by the following JSON schema:</p> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"title\": \"OMI_personality\",\n    \"description\": \"An extension for the glTF format that defines a personality for a node and an endpoint where additional information can be queried.\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"agent\": {\n            \"type\": \"string\",\n            \"description\": \"The name of the agent associated with the node.\",\n            \"maxLength\": 128\n        },\n        \"personality\": {\n            \"type\": \"string\",\n            \"description\": \"A description of the agent's personality.\"\n        },\n        \"defaultMessage\": {\n            \"type\": \"string\",\n            \"description\": \"The default message that the agent will send on initialization.\"\n        }\n    },\n    \"required\": [\"agent\", \"personality\"]\n}\n</code></pre>"},{"location":"OMI_personality/#implementation-details","title":"Implementation Details","text":"<p>The OMI_personality extension allows users to inject a unique personality into their virtual representations and adheres to a simple set of properties that aim to be compatible with lots of AI software to come. In the below example implementation, the data for personality is used to combine with the input from the user talking to the NPC. The final prompt is being sent to the OpenAI Davinci model to allow for completion of the agent's response.</p> <pre><code>    // Request coming from three.js frontend that is querying this endpoint making a call to the GPT-3 model. Contains the Personality data embeded in the NPC file.\n    const data = await request.json();\n    let prompt = data.inputs.personality;\n    let prompt = data.Input.personality;\n\n    let finalPrompt = prompt\n        .replaceAll('#speaker', data.Input.Speaker)\n        .replaceAll('#input', data.Input.Input)\n        .replaceAll('#agent', data.Input.Agent)\n        .replaceAll('#conversation', data.Input.Conversation)\n        .replaceAll('undefined\\n','' ).replaceAll('undefined','')\n        .slice(-5000)\n\n    const token = authorization.split(' ')[1];\n    const postData = {\n        prompt: finalPrompt,\n        max_tokens: 500,\n        stop : [\"###\"],\n        temperature: 0.7,\n    };\n\n    // Make the first request to the Davinci model\n    const davinciResponse = await fetch('https://api.openai.com/v1/engines/text-davinci-003/completions', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify(postData)\n    });\n\n</code></pre> <p>The final prompt in this examples follows a structure of:</p> <pre><code>Agent is cheerful and always willing to help with programming tasks. They are an entity that lives in a virtual world always looking for new and intersting ways to help humans create content in the metaverse.\nSpeaker: Hello agent! Tell me about yourself\nAgent:\n</code></pre> <p>The above example is a final prompt that is sent to OpenAI where the model completes what the \"Agent:\" would write to complete this conversation factoring in the personality data above the chat log.</p> <p>In this example, the text is being passed back to the Three.js scene and rendered in the scene using a Text component.</p>"},{"location":"OMI_physics_body/","title":"OMI_physics_body","text":""},{"location":"OMI_physics_body/#contributors","title":"Contributors","text":"<ul> <li>Aaron Franke, The Mirror Megaverse Inc.</li> <li>Mauve Signweaver, Mauve Software Inc.</li> </ul>"},{"location":"OMI_physics_body/#status","title":"Status","text":"<p>Open Metaverse Interoperability Group Stage 1 Proposal</p>"},{"location":"OMI_physics_body/#dependencies","title":"Dependencies","text":"<p>Written against the glTF 2.0 spec.</p> <p>Depends on the <code>OMI_physics_shape</code> spec to be useful.</p>"},{"location":"OMI_physics_body/#overview","title":"Overview","text":"<p>This extension allows for specifying physics bodies in glTF scenes.</p> <p>Nodes with the <code>OMI_physics_body</code> extension may define motion, collider, and trigger properties.</p> <p>If a node with a collider shape does not have a motion property on itself or an ancestor node, it should be a static solid object that does not move.</p>"},{"location":"OMI_physics_body/#example","title":"Example:","text":"<p>This example defines a static body node which has a single box collider as a child:</p> <pre><code>{\n    \"asset\": {\n        \"version\": \"2.0\"\n    },\n    \"extensions\": {\n        \"OMI_physics_shape\": {\n            \"shapes\": [\n                {\n                    \"type\": \"box\",\n                    \"box\": {\n                        \"size\": [1, 2, 3]\n                    }\n                }\n            ]\n        }\n    },\n    \"extensionsUsed\": [\n        \"OMI_physics_body\",\n        \"OMI_physics_shape\"\n    ],\n    \"nodes\": [\n        {\n            \"extensions\": {\n                \"OMI_physics_body\": {\n                    \"motion\": {\n                        \"type\": \"dynamic\"\n                    },\n                    \"collider\": {\n                        \"shape\": 0\n                    }\n                }\n            },\n            \"name\": \"DynamicBox\"\n        }\n    ],\n    \"scene\": 0,\n    \"scenes\": [{ \"nodes\": [0] }]\n}\n</code></pre> <p>The above example shows dynamic motion and collision shape specified on one node. A nearly identical example using 2 nodes can be found in examples/basic/dynamic_box.gltf.</p> <p>More example assets can be found in the examples/ folder. All of these examples use both <code>OMI_physics_shape</code> and <code>OMI_physics_body</code>.</p>"},{"location":"OMI_physics_body/#gltf-schema-updates","title":"glTF Schema Updates","text":"<p>This extension consists of a new <code>OMI_physics_body</code> data structure which can be added to a glTF node.</p> <p>The extension must also be added to the glTF's <code>extensionsUsed</code> array and because it is optional, it does not need to be added to the <code>extensionsRequired</code> array.</p> <p>The extension is intended to be used together with <code>OMI_physics_shape</code>, which defines the shapes used by the <code>\"shape\"</code> properties inside of the <code>\"collider\"</code> and <code>\"trigger\"</code> sub-JSON properties.</p>"},{"location":"OMI_physics_body/#property-summary","title":"Property Summary","text":"Type Description Default value motion JSON If present, this node has its motion controlled by physics. <code>null</code> collider JSON If present, this node is solid and can be collided with. <code>null</code> trigger JSON If present, this node is non-solid and can act as a trigger. <code>null</code> <p>Each of these properties are recommended to be defined on separate nodes. This results in a very clear, simple, and portable document structure, and ensures that each behavior has its own transform. However, they may also be all defined on the same node. Implementations must support all of these cases in order to be compliant.</p>"},{"location":"OMI_physics_body/#motion","title":"Motion","text":"<p>If a node has the <code>\"motion\"</code> property defined, its transform is driven by the physics engine.</p> <p>The list of motion properties and their details can be found in the README.motion.md file.</p>"},{"location":"OMI_physics_body/#collider","title":"Collider","text":"<p>If a node has the <code>\"collider\"</code> property defined, it is a solid collider node that objects can collide with.</p> <p>The list of collider properties and their details can be found in the README.collider.md file.</p>"},{"location":"OMI_physics_body/#trigger","title":"Trigger","text":"<p>If a node has the <code>\"trigger\"</code> property defined, it is a non-solid trigger that can detect when objects enter it.</p> <p>The list of trigger properties and their details can be found in the README.trigger.md file.</p>"},{"location":"OMI_physics_body/#json-schema","title":"JSON Schema","text":"<p>See node.OMI_physics_body.schema.json for the main node schema, and these for the sub-JSON property schemas: * Motion: node.OMI_physics_body.motion.schema.json * Collider: node.OMI_physics_body.collider.schema.json * Trigger: node.OMI_physics_body.trigger.schema.json</p>"},{"location":"OMI_physics_body/#known-implementations","title":"Known Implementations","text":"<ul> <li>Godot Engine: https://github.com/godotengine/godot/pull/78967</li> </ul>"},{"location":"OMI_physics_body/#resources","title":"Resources:","text":"<ul> <li>Unity colliders: https://docs.unity3d.com/Manual/CollidersOverview.html</li> <li>Unreal Engine Physics: https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Physics/Collision/Overview/</li> <li>Godot Physics Body: https://docs.godotengine.org/en/stable/classes/class_physicsbody.html</li> <li>Godot Area: https://docs.godotengine.org/en/stable/classes/class_area.html</li> <li>Godot RigidBody3D: https://docs.godotengine.org/en/latest/classes/class_rigidbody3d.html</li> <li>Wikipedia Moment of Inertia: https://en.wikipedia.org/wiki/Moment_of_inertia</li> <li>Wikipedia Rigid Body Dynamics: https://en.wikipedia.org/wiki/Rigid_body_dynamics</li> </ul>"},{"location":"OMI_physics_body/README.collider/","title":"OMI_physics_body Collider Property","text":"<p>If a node has the <code>\"collider\"</code> property defined, it is a solid collider node that objects can collide with.</p>"},{"location":"OMI_physics_body/README.collider/#collider-properties","title":"Collider Properties","text":"Type Description Default value shape <code>integer</code> The index of the shape to use as the collision shape. -1"},{"location":"OMI_physics_body/README.collider/#shape","title":"Shape","text":"<p>The <code>\"shape\"</code> property is an integer index that references a shape in the document-level shapes array as defined by the <code>OMI_physics_shape</code> extension. If not specified or -1, this node has no collider shape, but may be the parent of other nodes that do have collider shapes, and can combine those nodes into one collider (this may be a body or compound collider depending on the engine).</p>"},{"location":"OMI_physics_body/README.collider/#json-schema","title":"JSON Schema","text":"<p>See schema/node.OMI_physics_body.collider.schema.json for the collider properties JSON schema.</p>"},{"location":"OMI_physics_body/README.motion/","title":"OMI_physics_body Motion Property","text":"<p>If a node has the <code>\"motion\"</code> property defined, its transform is driven by the physics engine.</p> <ul> <li>Descendant nodes should move with that node. The physics engine should treat them as part of a single body.</li> <li>If a descendant node has its own motion property, that node should be treated as an independent body during simulation. There is no implicit requirement that it follows its \"parent\" rigid body.</li> <li>If a node's transform is animated by animations in the file, those animations should take priority over the physics simulation.</li> </ul>"},{"location":"OMI_physics_body/README.motion/#motion-properties","title":"Motion Properties","text":"Type Description Default value type <code>string</code> The type of the physics body as a string. Required, no default mass <code>number</code> The mass of the physics body in kilograms. 1.0 linearVelocity <code>number[3]</code> The initial linear velocity of the body in meters per second. [0.0, 0.0, 0.0] angularVelocity <code>number[3]</code> The initial angular velocity of the body in radians per second. [0.0, 0.0, 0.0] centerOfMass <code>number[3]</code> The center of mass offset from the origin in meters. [0.0, 0.0, 0.0] inertiaDiagonal <code>number[3]</code> The inertia around principle axes in kilogram meter squared (kg\u22c5m\u00b2). [0.0, 0.0, 0.0] inertiaOrientation <code>number[4]</code> The inertia orientation as a Quaternion. [0.0, 0.0, 0.0, 1.0]"},{"location":"OMI_physics_body/README.motion/#motion-types","title":"Motion Types","text":"<p>The <code>\"type\"</code> property is a lowercase string that defines what type of physics body this is. Different types of physics bodies have different interactions with physics systems and other bodies within a scene.</p> <p>Here is a table listing the mapping between the <code>OMI_physics_body</code> type and the equivalent types in major game engines.</p> Body Type Unity Godot 3 Godot 4 Unreal Static Collider StaticBody StaticBody3D WorldStatic, Simulate Physics = false Kinematic Rigidbody.isKinematic KinematicBody AnimatableBody3D WorldDynamic, Simulate Physics = false Dynamic Rigidbody RigidBody RigidBody3D PhysicsBody, Simulate Physics = true"},{"location":"OMI_physics_body/README.motion/#static","title":"Static","text":"<p>Static bodies can be collided with, but do not have simulated movement. They are usually used for level geometry. Specifying a static body is optional, as nodes with collider properties are assumed to be static without itself or a parent node having the motion property.</p>"},{"location":"OMI_physics_body/README.motion/#kinematic","title":"Kinematic","text":"<p>Kinematic bodies can be collided with, and can be moved using scripts or animations. They can be used for moving platforms.</p>"},{"location":"OMI_physics_body/README.motion/#dynamic","title":"Dynamic","text":"<p>Dynamic bodies are bodies simulated with rigid body dynamics. They collide with other bodies, and move around on their own in the physics simulation. They are affected by gravity. They can be used for props that move around in the world.</p>"},{"location":"OMI_physics_body/README.motion/#mass","title":"Mass","text":"<p>The <code>\"mass\"</code> property is a number that defines how much mass this physics body has in kilograms. Not all body types can make use of mass, such as triggers or non-moving bodies, in which case the mass can be ignored. If not specified, the default value is 1 kilogram.</p>"},{"location":"OMI_physics_body/README.motion/#linear-velocity","title":"Linear Velocity","text":"<p>The <code>\"linearVelocity\"</code> property is an array of three numbers that defines how much linear velocity this physics body starts with in meters per second. Not all body types can make use of linear velocity, such as non-moving bodies, in which case the linear velocity can be ignored. If not specified, the default value is zero.</p>"},{"location":"OMI_physics_body/README.motion/#angular-velocity","title":"Angular Velocity","text":"<p>The <code>\"angularVelocity\"</code> property is an array of three numbers that defines how much angular velocity this physics body starts with in radians per second. Not all body types can make use of angular velocity, such as non-moving bodies, in which case the angular velocity can be ignored. If not specified, the default value is zero.</p>"},{"location":"OMI_physics_body/README.motion/#center-of-mass","title":"Center of Mass","text":"<p>The <code>\"centerOfMass\"</code> property is an array of three numbers that defines the position offset in meters of the center of mass in the body's local space. If not specified, the default value is zero.</p> <p>This property is useful when converting assets with a center of mass, but when creating new assets it is recommended to leave the center of mass at the body's origin. Some physics engines support the center of mass being offset from the origin, but not all of them do. Implementations without support for a center of mass offset would have to adjust the node positions to make this work, which may be undesired.</p>"},{"location":"OMI_physics_body/README.motion/#inertia-diagonal","title":"Inertia Diagonal","text":"<p>The <code>\"inertiaDiagonal\"</code> property is an array of 3 numbers that defines the inertia around the principle axes of the body in kilogram meter squared (kg\u22c5m\u00b2). We specify \"tensor\" in the name because this defines inertia in multiple directions and is different from linear momentum inertia. Only the \"dynamic\" motion type can make use of inertia. If zero or not specified, the inertia should be automatically calculated by the physics engine.</p>"},{"location":"OMI_physics_body/README.motion/#inertia-orientation","title":"Inertia Orientation","text":"<p>The <code>\"inertiaOrientation\"</code> property is an array of 4 numbers that defines a Quaternion for orientation of the inertia's principle axes relative to the body's local space. If not specified or set to the default value of <code>[0.0, 0.0, 0.0, 1.0]</code>, no rotation is applied, the inertia's principle axes are aligned with the body's local space axes.</p>"},{"location":"OMI_physics_body/README.motion/#json-schema","title":"JSON Schema","text":"<p>See schema/node.OMI_physics_body.motion.schema.json for the motion properties JSON schema.</p>"},{"location":"OMI_physics_body/README.trigger/","title":"OMI_physics_body Trigger Property","text":"<p>A useful construct in a physics engine is a non-solid volume of space which does not generate impulses when overlapping with other volumes. These objects are typically called \"triggers\", \"sensors\", \"phantoms\", or \"overlap volumes\" in physics simulation engines. Triggers allow specifying such volumes either as a single shape or combination of nodes with shapes.</p> <p>A trigger is added to a glTF node by specifying the <code>\"trigger\"</code> property inside of a node's <code>\"OMI_physics_body\"</code> extension.</p> <p>A <code>\"trigger\"</code> may specify a <code>\"shape\"</code> property which references a geometric shape defined by the <code>OMI_physics_shape</code> extension. Alternatively, a <code>\"trigger\"</code> may have a <code>\"nodes\"</code> property, which is an array of glTF nodes which make up a compound trigger on this glTF node. The nodes in this array must be descendent nodes which must have <code>\"trigger\"</code> properties. At least one of <code>\"shape\"</code> or <code>\"nodes\"</code> must be set to a valid value.</p> <p>As the name \"trigger\" suggests, implementations may use these shapes as sensors that generate overlap events, which can be used to trigger things. What behavior gets triggered is outside the scope of this extension, but may be defined in other glTF extensions or application-specific logic.</p>"},{"location":"OMI_physics_body/README.trigger/#trigger-properties","title":"Trigger Properties","text":"Type Description Default value shape <code>integer</code> The index of the shape to use as the trigger shape. -1 nodes <code>integer[]</code> For compound triggers, the set of descendant glTF nodes with a trigger property that make up this compound trigger. []"},{"location":"OMI_physics_body/README.trigger/#shape","title":"Shape","text":"<p>The <code>\"shape\"</code> property is an integer index that references a shape in the document-level shapes array as defined by the <code>OMI_physics_shape</code> extension. If not specified or -1, this node has no trigger shape, but may have <code>\"nodes\"</code> defined to create a compound trigger.</p>"},{"location":"OMI_physics_body/README.trigger/#nodes","title":"Nodes","text":"<p>The <code>\"nodes\"</code> property is an array of integer indices that reference descendant glTF nodes with a trigger property, which make up a compound trigger on this glTF node. If not specified or empty, this node is not a compound trigger.</p> <p>When this property is set and contains valid items, this indicates that this glTF node is a compound trigger. Each item is the index of a glTF node that must have its own OMI_physics_body trigger property, and must be a descendant of this node.</p>"},{"location":"OMI_physics_body/README.trigger/#json-schema","title":"JSON Schema","text":"<p>See schema/node.OMI_physics_body.trigger.schema.json for the trigger properties JSON schema.</p>"},{"location":"OMI_physics_gravity/","title":"OMI_physics_gravity","text":""},{"location":"OMI_physics_gravity/#contributors","title":"Contributors","text":"<ul> <li>Aaron Franke, Godot Engine.</li> </ul>"},{"location":"OMI_physics_gravity/#status","title":"Status","text":"<p>Open Metaverse Interoperability Group Stage 1 Proposal</p>"},{"location":"OMI_physics_gravity/#dependencies","title":"Dependencies","text":"<p>Written against the glTF 2.0 spec.</p> <p>Depends on the <code>OMI_physics_body</code> and <code>OMI_physics_shape</code> specs for per-node gravity volumes.</p>"},{"location":"OMI_physics_gravity/#overview","title":"Overview","text":"<p>This extension allows specifying gravity volumes on trigger glTF nodes and specifying the global world gravity at the document level.</p> <p>Global world gravity is always directional. A document-level extension may define the magnitude and direction of the global world gravity. Only one or zero instanced glTF files should have the document-level extension. The intention is to use the document-level extension only on the main \"map\" glTF. If multiple glTF files have the document-level gravity extension, use the most recently instanced glTF model's gravity (when instancing, override the previous gravity).</p> <p>For a per-node gravity volume, the <code>OMI_physics_gravity</code> extension MUST be defined on an <code>OMI_physics_body</code> node that is a base trigger node. Meaning, the glTF node has a trigger property, does not have motion or collider properties, and must not be a child shape of a compound trigger, as only one gravity definition is allowed per compound trigger. The shape of where the gravity influence is experienced is defined by the trigger shapes. The details of which way the gravity points can be specified in a variety of types, which are described in more detail below.</p> <p>Whether or not a rigid body is influenced by a gravity volume is determined by the priority/replace/stop settings of each gravity volume the body is inside of. The priority integer determines the order in which gravity volumes are calculated, with higher values being calculated first, and the global world gravity is always calculated last. The replace boolean controls whether or not to keep gravity already calculated so far from higher priority nodes. The stop boolean controls whether or not to continue calculating gravity from any lower priority nodes and the global world gravity. If only the default settings are used, where replace and stop are both false, the gravity is combined from all gravity volumes and the global world gravity.</p>"},{"location":"OMI_physics_gravity/#example","title":"Example:","text":"<p>This example defines a scene with a millionth-scale Earth planet in space. This is the same as earth_millionth_scale.gltf except slimmed down to only a single glTF node, the one related to gravity. It is a fully complete file that can be loaded into any app that supports this extension.</p> <p>In this example, the global world gravity is set to zero to mimic space. There is an Earth object with point gravity and a radius of 6.37814. The gravity strength is 9.80665 at the unit distance of 6.37814. The area of effect is a sphere with a radius of 40 units, which means the gravity cuts off to zero at a distance of 40 units from the center. Dynamic objects overlapping this sphere will be pulled towards the center by an amount determined by their distance and the field's gravity and unit distance, following the inverse square law.</p> <pre><code>{\n    \"asset\": {\n        \"version\": \"2.0\"\n    },\n    \"extensions\": {\n        \"OMI_physics_gravity\": {\n            \"gravity\": 0.0\n        },\n        \"OMI_physics_shape\": {\n            \"shapes\": [\n                {\n                    \"type\": \"sphere\",\n                    \"radius\": 40.0\n                }\n            ]\n        }\n    },\n    \"extensionsUsed\": [\n        \"OMI_physics_body\",\n        \"OMI_physics_gravity\",\n        \"OMI_physics_shape\"\n    ],\n    \"nodes\": [\n        {\n            \"name\": \"EarthGravity\",\n            \"extensions\": {\n                \"OMI_physics_body\": {\n                    \"trigger\": {\n                        \"shape\": 0\n                    }\n                },\n                \"OMI_physics_gravity\": {\n                    \"gravity\": 9.80665,\n                    \"point\": {\n                        \"unitDistance\": 6.37814\n                    },\n                    \"type\": \"point\"\n                }\n            }\n        }\n    ],\n    \"scene\": 0,\n    \"scenes\": [{ \"nodes\": [0] }]\n}\n</code></pre> <p>More example assets can be found in the examples/ folder.</p>"},{"location":"OMI_physics_gravity/#gltf-schema-updates","title":"glTF Schema Updates","text":"<p>This extension consists of two new data structures for defining gravity.</p> <ul> <li> <p>For the root glTF document, the key <code>\"OMI_physics_gravity\"</code> in the document-level <code>\"extensions\"</code> defines global gravity for the whole world, including the entire glTF scene and any other instanced scenes. The global gravity is always directional.</p> </li> <li> <p>For a glTF node, the key <code>\"OMI_physics_gravity\"</code> in the node-level <code>\"extensions\"</code> defines gravity for a trigger volume as defined by <code>OMI_physics_body</code>. The area of effect is determined by the trigger volume's shapes. Objects in this volume may be affected by its gravity, depending on the priority, replace, and stop settings of gravity volumes affecting this part of space. The type of gravity determines which way the gravity points within the gravity field, and how strongly.</p> </li> </ul> <p>The extension must also be added to the glTF's <code>extensionsUsed</code> array and because it is optional, it does not need to be added to the <code>extensionsRequired</code> array.</p>"},{"location":"OMI_physics_gravity/#property-summary","title":"Property Summary","text":"<p>The following properties apply to the document-level extension defining the world gravity:</p> Type Description Default value Valid on gravity <code>number</code> The gravity amount in meters per second squared. Can be zero or negative. Required, no default Always valid direction <code>number[3]</code> The normalized direction of the gravity. World gravity is always directional. [0.0, -1.0, 0.0] Always valid <p>Note: Only one or zero instanced glTF files should have the document-level gravity extension. The intention is to only use the document-level extension on the main \"map\" glTF. If multiple glTF files have the document-level gravity extension, use the most recently instanced glTF file's gravity.</p> <p>The following properties apply to the gravity of each node, and is a superset of the world gravity properties:</p> Type Description Default value Valid on type <code>string</code> The type of the gravity as a string. Required, no default Always valid gravity <code>number</code> The gravity amount in meters per second squared. Can be zero or negative. Required, no default Always valid priority <code>number</code> The process priority of this gravity node. Must be an integer. 0 Always valid replace <code>boolean</code> If true, replace the current gravity instead of adding to it. false Always valid stop <code>boolean</code> If true, stop checking more nodes for gravity. false Always valid <p>In addition to the type, a key with the same name as the type can be used to define a sub-JSON with the details of the shape. Which sub-properties are allowed depend on which shape type is being used. The possible properties are described in the following table.</p> Type Description Default value Valid on direction <code>number[3]</code> The normalized direction of the gravity relative to this node's transform. [0.0, -1.0, 0.0] Directional unitDistance <code>number</code> The distance from the nearest point at which the experienced gravity equals the gravity property. 0.0 Non-directional radius <code>number</code> The radius of the circle to attract gravity towards. 1.0 Disc, torus points <code>number[]</code> The points that make up the line segments of a line type gravity field. [] Line shape <code>number</code> The integer ID of a physics shape used to define the gravity direction. -1 Shaped"},{"location":"OMI_physics_gravity/#type","title":"Type","text":"<p>The <code>\"type\"</code> property is a string that defines the type of the gravity. This property is only valid on node gravity, for world gravity the type is always directional.</p> <p>The type value may be set to <code>\"directional\"</code>, <code>\"point\"</code>, <code>\"disc\"</code>, <code>\"torus\"</code>, <code>\"line\"</code>, or <code>\"shaped\"</code>.</p> <p>On a node, the type property must be set to one of the below values, otherwise the behavior is undefined. Further details of the gravity type are defined in a sub-JSON with the same name as the type. The possible properties in this sub-JSON are defined in the above table. If the sub-JSON is not present or is missing a property, the default value should be used.</p> <p>The type property is not to be confused with the shape of the gravity volume. The trigger body's shape nodes define the area in which the gravity will affect objects. The type property defines which way the gravity points and how it scales with distance.</p> <p>The directional and point gravity types are the easiest to implement and fastest to calculate. Preference should be given to these types when they are suitable for the desired use case.</p>"},{"location":"OMI_physics_gravity/#directional","title":"Directional","text":"<p><code>\"directional\"</code> gravity defines uniform parallel gravity with a given direction at the given strength. The direction is defined relative to the node's transform with the <code>\"direction\"</code> property.</p>"},{"location":"OMI_physics_gravity/#point","title":"Point","text":"<p><code>\"point\"</code> gravity defines gravity that points towards a single point, the trigger volume's origin. The <code>\"unitDistance\"</code> property defines the distance from the center at which the actual gravity equals the <code>\"gravity\"</code> property, unless <code>\"unitDistance\"</code> is zero, in which case the gravity is constant regardless of distance.</p> <p>The vector to the trigger body's origin determines the direction of gravity. The gravity strength is determined by that vector and the <code>\"unitDistance\"</code> property, unless <code>\"unitDistance\"</code> is zero, in which case the gravity is constant regardless of distance.</p> <p>The point type can be used to define gravity for a spherical planet, with the unit distance property being set to the radius of the planet.</p>"},{"location":"OMI_physics_gravity/#disc","title":"Disc","text":"<p><code>\"disc\"</code> gravity defines gravity that points toward the nearest point in a filled circle. The <code>\"radius\"</code> property defines the radius of the circle. The orientation of the circle is flat on the local XZ plane of the node.</p> <p>The vector to the nearest point in the filled circle determines the direction of gravity. The gravity strength is determined by that vector and the <code>\"unitDistance\"</code> property, unless <code>\"unitDistance\"</code> is zero, in which case the gravity is constant regardless of distance.</p> <p>The disc type can be conceptually thought of as two directional gravity fields on either side of the circle, connected by a smooth semicircle transition on the edge.</p>"},{"location":"OMI_physics_gravity/#torus","title":"Torus","text":"<p><code>\"torus\"</code> gravity defines gravity that points toward the nearest point on the edge of a hollow circle. The <code>\"radius\"</code> property defines the radius of the circle. The orientation of the circle is flat on the local XZ plane of the node.</p> <p>The vector to the nearest point on the edge of the hollow circle determines the direction of gravity. The gravity strength is determined by that vector and the <code>\"unitDistance\"</code> property, unless <code>\"unitDistance\"</code> is zero, in which case the gravity is constant regardless of distance.</p> <p>The torus type can be used to define gravity for a toroidal planet, with the major radius of the torus being the radius property, and the minor radius of the torus being the unit distance property (or in the case of constant gravity, the minor radius does not need to be set to any parameter).</p>"},{"location":"OMI_physics_gravity/#line","title":"Line","text":"<p><code>\"line\"</code> gravity defines gravity using series of line segments defined by a series of points. The <code>\"points\"</code> property is an array of numbers that defines these points relative to the node's transform. The size of <code>\"points\"</code> must be a multiple of 3 numbers and must contain at least 6 numbers.</p> <p>The vector to the nearest point on any of the line segments determines the direction of gravity. The gravity strength is determined by that vector and the <code>\"unitDistance\"</code> property, unless <code>\"unitDistance\"</code> is zero, in which case the gravity is constant regardless of distance.</p> <p>The line type is a flexible type that defines gravity towards arbitrary lines. It can be used with only 2 points to define simple shapes like gravity for cylinder or capsule planets, or with many points to define a complex snake-like gravity field.</p>"},{"location":"OMI_physics_gravity/#shaped","title":"Shaped","text":"<p><code>\"shaped\"</code> gravity defines gravity towards the nearest point on a physics shape. This is not to be confused with the trigger shape that defines the area of effect. The <code>\"shape\"</code> property references the ID of a shape as defined by <code>OMI_physics_shape</code>.</p> <p>The vector to the nearest point on the shape determines the direction of gravity. The gravity strength is determined by that vector and the <code>\"unitDistance\"</code> property, unless <code>\"unitDistance\"</code> is zero, in which case the gravity is constant regardless of distance.</p> <p>The shaped type is a flexible type that can be used to create things like cube-shaped planets or giving gravity to arbitrary surfaces with minimal effort.</p>"},{"location":"OMI_physics_gravity/#gravity","title":"Gravity","text":"<p>The <code>\"gravity\"</code> property is a number that defines the gravity strength in meters per second squared. Required. Can be zero or negative. If negative, the gravity points in the opposite direction of the direction vector in the case of directional gravity, or away from the nearest point of the other gravity types.</p>"},{"location":"OMI_physics_gravity/#direction","title":"Direction","text":"<p>The <code>\"direction\"</code> property is a vector as a three-number array. It is only valid for directional gravity.</p> <p>It defines the direction of the gravity relative to this node's transform. Should be normalized. If not specified, the default value is a unit vector pointing downwards, <code>[0.0, -1.0, 0.0]</code>.</p>"},{"location":"OMI_physics_gravity/#unit-distance","title":"Unit Distance","text":"<p>The <code>\"unitDistance\"</code> property is a number that defines how gravity scales with distance. It is only valid for non-directional gravity.</p> <p>It defines how the gravity strength should scale based on the distance to the nearest point. If zero, the gravity is constant regardless of distance. This value should not be negative. If not specified, the default value is 0.0.</p> <p>If positive, it defines the distance from the center point in meters at which the actual gravity equals the gravity amount. The gravity should have squared falloff following the inverse square law. For example, if the unit distance is 10 meters and the physics body is 20 meters away, then the experienced gravity magnitude is one quarter of the gravity property. Similarly, if the unit distance is 10 meters and the physics body is 5 meters away, then the experienced gravity magnitude is four times the gravity property.</p>"},{"location":"OMI_physics_gravity/#radius","title":"Radius","text":"<p>The <code>\"radius\"</code> property is a number that defines the radius of the circle to attract gravity towards. It is only valid for disc and torus gravity.</p> <p>The orientation of the circle is flat on the local XZ plane of the node. If not specified, the default value is 1.0.</p>"},{"location":"OMI_physics_gravity/#points","title":"Points","text":"<p>The <code>\"points\"</code> property is an array of vectors, each made of 3 numbers. It is only valid for line gravity.</p> <p>The size of <code>\"points\"</code> must be a multiple of 3 numbers and must contain at least 6 numbers. If not specified, the default value is an empty array, which is an invalid value and will have no effect.</p>"},{"location":"OMI_physics_gravity/#shape","title":"Shape","text":"<p>The <code>\"shape\"</code> property is an integer that defines the ID of a physics shape as defined by <code>OMI_physics_shape</code>. It is only valid for shaped gravity.</p> <p>Defines the shape which is used to determine the direction of gravity. If not specified, the default value is -1, meaning the shape is invalid and will have no effect.</p>"},{"location":"OMI_physics_gravity/#priority","title":"Priority","text":"<p>The <code>\"priority\"</code> property is an integer that defines the process order of this gravity node. Must be an integer.</p> <p>Higher priority gravity nodes are processed first. The world gravity is always processed last, after all gravity nodes. If not specified, the default value is 0.</p> <p>Asset creators are highly encouraged to use priority numbers with large gaps, such as thousands or hundreds. This allows for adding new priority values in-between later. For example, a glTF file could have gravity nodes with priorities 1000 and 2000, then another gravity node can later be inserted in-between with a priority of 1500 without changing the existing gravity nodes. This can be repeated for adding a gravity node between 1000 and 1500, etc. If there are small volumes expected to be processed first, they should have very high priority values (positive thousands), while maps and other large volumes that are expected to be processed last should have very low negative priority (negative thousands).</p>"},{"location":"OMI_physics_gravity/#replace","title":"Replace","text":"<p>The <code>\"replace\"</code> property is a boolean. If not specified, the default value is false.</p> <p>If true, the gravity of this gravity volume replaces the calculated gravity instead of adding to it. This discards all previously applied gravity of higher priority nodes.</p>"},{"location":"OMI_physics_gravity/#stop","title":"Stop","text":"<p>The <code>\"stop\"</code> property is a boolean. If not specified, the default value is false.</p> <p>If true, stop checking more gravity volume nodes for gravity. This means that lower priority gravity nodes will be ignored. This also ignores the world gravity, which is always calculated last.</p>"},{"location":"OMI_physics_gravity/#additional-examples","title":"Additional Examples","text":"<p>The gravity types described above can be used in a variety of ways to create a wide variety of gravity types. Here are some examples of how to use the above gravity types to define other gravity shapes.</p> Example name Description Capsule Line gravity with 2 points where the line spans the mid-height and is fully inside the trigger volume. Cylinder Line gravity with 2 points where the line touches or surpasses the ends of the trigger volume. Wedge Line gravity with 2 points where the line is defined at the corner edge of a trigger volume. Cone Line gravity with 2 points, plus directional gravity pointing towards the large end of the cone."},{"location":"OMI_physics_gravity/#json-schema","title":"JSON Schema","text":"<p>See schema/glTF.OMI_physics_gravity.schema.json for document-level gravity, schema/node.OMI_physics_gravity.schema.json for node-level gravity, and the <code>schema/node.OMI_physics_gravity.*.schema.json</code> files for the sub-JSON schemas for gravity types.</p>"},{"location":"OMI_physics_gravity/#known-implementations","title":"Known Implementations","text":"<ul> <li>Godot Engine add-on</li> </ul>"},{"location":"OMI_physics_gravity/#resources","title":"Resources:","text":"<ul> <li>Godot Area3D: https://docs.godotengine.org/en/latest/classes/class_area3d.html</li> <li>Gravity in Super Mario Galaxy: https://www.youtube.com/watch?v=QLH_0T_xv3I</li> </ul>"},{"location":"OMI_physics_joint/","title":"OMI_physics_joint","text":""},{"location":"OMI_physics_joint/#contributors","title":"Contributors","text":"<ul> <li>Aaron Franke, The Mirror Megaverse Inc.</li> </ul>"},{"location":"OMI_physics_joint/#status","title":"Status","text":"<p>Open Metaverse Interoperability Group Stage 1 Proposal</p>"},{"location":"OMI_physics_joint/#dependencies","title":"Dependencies","text":"<p>Written against the glTF 2.0 spec.</p> <p>Depends on the <code>OMI_physics_body</code> spec, which depends on the <code>OMI_physics_shape</code> spec.</p>"},{"location":"OMI_physics_joint/#overview","title":"Overview","text":"<p>This extension allows defining a glTF node as a physics joint for constraining dynamic bodies.</p> <p>Each physics joint node is a separate node that references the two bodies it joints together. At least one of the bodies must be a dynamic body (<code>OMI_physics_body</code> motion type \"dynamic\") for the joint to function. One or zero of the connected nodes may be a solid body that joints cannot move (<code>OMI_physics_body</code> motion type \"static\" or \"kinematic\"). A joint cannot be connected to a trigger body, and cannot be connected to a non-<code>OMI_physics_body</code> glTF node.</p> <p>Each physics joint node must reference one or more joint constraints defined in the document-level joint constraints array.</p> <p>A joint should be on its own glTF node, it should not be on the same node as a mesh, camera, light, physics body, physics shape, etc.</p>"},{"location":"OMI_physics_joint/#example","title":"Example:","text":"<p>This example defines 2 dynamic bodies that are connected with a joint that constrains linearly on a fixed point, also known as a \"pin\" joint. This example JSON is a subset of the examples/simple_joint.gltf file.</p> <pre><code>{\n    \"asset\": {\n        \"version\": \"2.0\"\n    },\n    \"extensionsUsed\": [\n        \"OMI_physics_body\",\n        \"OMI_physics_joint\",\n        \"OMI_physics_shape\"\n    ],\n    \"extensions\": {\n        \"OMI_physics_joint\": {\n            \"constraints\": [\n                {\n                    \"linearAxes\": [0, 1, 2]\n                }\n            ]\n        }\n    },\n    \"nodes\": [\n        {\n            \"extensions\": {\n                \"OMI_physics_joint\": {\n                    \"constraints\": [0],\n                    \"nodeA\": 1,\n                    \"nodeB\": 2\n                }\n            },\n            \"name\": \"PinJoint\",\n            \"translation\": [-0.23, 0.6, 0.0]\n        },\n        {\n            \"extensions\": {\n                \"OMI_physics_body\": {\n                    \"motion\": {\n                        \"type\": \"dynamic\"\n                    }\n                }\n            },\n            \"name\": \"BodyA\",\n            \"rotation\": [0.0, 0.0, -0.17364804446697, 0.984807789325714],\n            \"translation\": [-0.45, 0.68, 0.0]\n        },\n        {\n            \"extensions\": {\n                \"OMI_physics_body\": {\n                    \"motion\": {\n                        \"type\": \"dynamic\"\n                    }\n                }\n            },\n            \"name\": \"BodyB\",\n            \"translation\": [0.0, 0.6, 0.0]\n        }\n    ]\n}\n</code></pre> <p>More example assets can be found in the examples/ folder.</p>"},{"location":"OMI_physics_joint/#gltf-schema-updates","title":"glTF Schema Updates","text":"<p>This extension consists of three new data structures for defining joints. A glTF file with joints should have a document-level <code>\"OMI_physics_joint\"</code> object added to the document <code>\"extensions\"</code> which contains an array of joint constraints. Each joint constraint is an object defined as the below spec. Then, the key <code>\"OMI_physics_joint\"</code> can be added to the node-level <code>\"extensions\"</code> of a glTF node to define that node as a physics joint. Each joint node has an array of constraints that references the document-level constraints array by index, and each joint node also references 2 physics body nodes.</p> <p>The extension must also be added to the glTF's <code>extensionsUsed</code> array and because it is optional, it does not need to be added to the <code>extensionsRequired</code> array.</p>"},{"location":"OMI_physics_joint/#joint-constraint-property-summary","title":"Joint Constraint Property Summary","text":"Type Description Default value linearAxes <code>number[0..3]</code> The axes to constrain. Can only contain 0 (X), 1 (Y), or 2 (Z). [] (empty array) angularAxes <code>number[0..3]</code> The axes to constrain. Can only contain 0 (X), 1 (Y), or 2 (Z). [] (empty array) lowerLimit <code>number</code> The lower limit of the constraint, in meters or radians. 0.0 upperLimit <code>number</code> The lower limit of the constraint, in meters or radians. 0.0 stiffness <code>number</code> The stiffness of the limits, how hard to spring back when beyond. Infinity damping <code>number</code> When beyond the limits, the damping of the springing back motion. 1.0 <p>A joint constraint should define at least one linear axis or one angular axis, otherwise the joint constraint will not perform any constraints.</p> <p>The reason that joints constraints are defined at the document-level and referenced on nodes is because it's very common to have many joints with the same constraints. For example, a long rope using many bodies each with pin joints (linear axes constrained) would have the same joint constraints repeated many times, but with different nodes attached.</p>"},{"location":"OMI_physics_joint/#linear-axes","title":"Linear Axes","text":"<p>The <code>\"linearAxes\"</code> property defines a list of linear axes to constrain. Can only contain 3 possible values, 0 (X), 1 (Y), or 2 (Z). If empty or not specified, this joint constraint does not constrain linearly.</p>"},{"location":"OMI_physics_joint/#angular-axes","title":"Angular Axes","text":"<p>The <code>\"angularAxes\"</code> property defines a list of angular axes to constrain. Can only contain 3 possible values, 0 (X), 1 (Y), or 2 (Z). If empty or not specified, this joint constraint does not constrain angularly.</p>"},{"location":"OMI_physics_joint/#lower-limit","title":"Lower Limit","text":"<p>The <code>\"lowerLimit\"</code> property defines the lower limit of the constraint in meters or radians, depending on whether the constraint is linear or angular. If not specified, the default value is 0.0.</p> <p>The lower limit must be less than or equal to the upper limit, otherwise the constraint is invalid. If the lower and upper limits are equal, the constraint is fixed on that value.</p>"},{"location":"OMI_physics_joint/#upper-limit","title":"Upper Limit","text":"<p>The <code>\"upperLimit\"</code> property defines the upper limit of the constraint in meters or radians, depending on whether the constraint is linear or angular. If not specified, the default value is 0.0.</p> <p>The upper limit must be greater than or equal to the lower limit, otherwise the constraint is invalid. If the lower and upper limits are equal, the constraint is fixed on that value.</p>"},{"location":"OMI_physics_joint/#stiffness","title":"Stiffness","text":"<p>The <code>\"stiffness\"</code> property defines how soft or hard the limits are, and how much force should be applied to the bodies to spring back once they surpasses the limits. Must be positive. If not specified, the default value is infinity.</p> <p>A lower value indicates a softer limit, while a higher value indicades a harder limit. A value of infinity means the limits should be completely hard and may not be surpassed. Implementations are expected to clamp this to within the limits of the physics engine. For example, if a physics engine cannot handle an infinite stiffness, it should be set to a high value, since an extremely stiff joint is close enough to an infinitely stiff joint. For more information, see the Wikipedia article on stiffness.</p>"},{"location":"OMI_physics_joint/#damping","title":"Damping","text":"<p>The <code>\"damping\"</code> property defines the amount of damping the bodies should experience while the bodies surpasses the limits and are springing back to be within them. Damping must not be applied when within the limits. Must be non-negative. If not specified, the default value is 1.0.</p>"},{"location":"OMI_physics_joint/#node-property-summary","title":"Node Property Summary","text":"Type Description Default value constraints <code>number[]</code> Array of indices in the document-level constraint array. Must be integers. Required, no default nodeA <code>number</code> Node index of one physics body used by the joint. Must be an integer. Required, no default nodeB <code>number</code> Node index of one physics body used by the joint. Must be an integer. Required, no default"},{"location":"OMI_physics_joint/#constraints","title":"Constraints","text":"<p>The <code>\"constraints\"</code> property defines the joint constraints to use for this joint. Must be an array of integers which are the index of the constraint in the document-level array.</p> <p>If a joint node has multiple joint constraints that overlap each other, later constraints should override the previous constraints.</p>"},{"location":"OMI_physics_joint/#node-a-and-node-b","title":"Node A and Node B","text":"<p>Each of these properties defines one of two bodies used by the joint. Must be an integer which is the index of the glTF node, and that node must be a physics body defined using the <code>OMI_physics_body</code> spec.</p> <p>At least one of the connected nodes must be a physics body using dynamic rigid body physics, meaning <code>OMI_physics_body</code> motion type set to \"dynamic\". If neither node is using dynamic rigid body physics, the joints will not work. When physics body nodes are joined, they should not collide with each other. One or zero of the nodes can be a solid body that cannot be moved by joints, meaning <code>OMI_physics_body</code> motion type set to \"static\" or \"kinematic\". A connected node cannot be null, cannot be a non-body, and cannot be a trigger body.</p> <p>The position on the body on which the joint operates is determined by the position of the joint relative to each body node. As such, the initial position of the joint node matters.</p>"},{"location":"OMI_physics_joint/#document-property-summary","title":"Document Property Summary","text":"Type Description Default value constraints <code>object[]</code> Array of joint constraint objects. Required, no default"},{"location":"OMI_physics_joint/#special-cases","title":"Special Cases","text":"<p>While a generic joint type is very useful and extensible, it's also worth defining when a generic joint is equivalent to a special-purpose joint. These mappings can be used to convert to more optimized joint types if supported in a physics engine, or as simply a friendly name to display to a user.</p> <p>In this chart, \"fixed\" means \"constrained with lower and upper limits set to zero\", and \"free\" means \"not constrained\".</p> Special case name Description Fixed / Weld Joint All axes fixed. Pin Joint All linear axes fixed, all angular axes free. Hinge Joint One angular axis constrained with non-equal lower and upper limits, the rest are fixed. Slider Joint One linear axis and optionally the angular axis around it constrained with non-equal lower and upper limits, the rest are fixed."},{"location":"OMI_physics_joint/#json-schema","title":"JSON Schema","text":"<p>See glTF.OMI_physics_joint.joint_constraint.schema.json, node.OMI_physics_joint.schema.json, and glTF.OMI_physics_joint.schema.json for the schemas.</p>"},{"location":"OMI_physics_joint/#known-implementations","title":"Known Implementations","text":"<ul> <li>Godot Engine add-on</li> </ul>"},{"location":"OMI_physics_joint/#resources","title":"Resources:","text":"<ul> <li>Godot Joint3D https://docs.godotengine.org/en/latest/classes/class_generic6dofjoint3d.html</li> <li>Unity Joints https://docs.unity3d.com/Manual/Joints.html</li> <li>Wikipedia Stiffness https://en.wikipedia.org/wiki/Stiffness</li> </ul>"},{"location":"OMI_physics_shape/","title":"OMI_physics_shape","text":""},{"location":"OMI_physics_shape/#contributors","title":"Contributors","text":"<ul> <li>Aaron Franke, The Mirror Megaverse Inc.</li> <li>Robert Long, The Matrix.org Foundation</li> <li>Mauve Signweaver, Mauve Software Inc.</li> </ul>"},{"location":"OMI_physics_shape/#status","title":"Status","text":"<p>Open Metaverse Interoperability Group Stage 1 Proposal</p>"},{"location":"OMI_physics_shape/#dependencies","title":"Dependencies","text":"<p>Written against the glTF 2.0 spec.</p> <p>Does nothing on its own. Designed to be used together with the <code>OMI_physics_body</code> spec.</p>"},{"location":"OMI_physics_shape/#overview","title":"Overview","text":"<p>This extension allows specifying physics shapes to be used in glTF scenes.</p> <p>All types of physics shapes defined in this extension are intended to be used for physics simulations and to be portable between many engines. Without another extension using it, this extension does not mandate any particular behavior for the shapes aside from their geometric properties. The precise usage of these physics shape primitives SHOULD be specified by the extenions which utilize them. In general, these physics shapes are used to specify geometry which can be used for collision detection.</p> <p>The <code>OMI_physics_shape</code> extension is intended to be used together with the <code>OMI_physics_body</code> extension, which allows attaching shapes to glTF nodes and specifying their behavior, including static, kinematic, dynamic, and non-solid triggers. The <code>OMI_physics_body</code> extension refers to a shape using an index of a shape in the <code>OMI_physics_shape</code> document-level shapes array.</p>"},{"location":"OMI_physics_shape/#example","title":"Example:","text":"<p>This example defines a single box shape with a size of 1 meter in all dimensions:</p> <pre><code>{\n    \"asset\": {\n        \"version\": \"2.0\"\n    },\n    \"extensions\": {\n        \"OMI_physics_shape\": {\n            \"shapes\": [\n                {\n                    \"type\": \"box\",\n                    \"box\": {\n                        \"size\": [1, 1, 1]\n                    }\n                }\n            ]\n        }\n    },\n    \"extensionsUsed\": [\n        \"OMI_physics_shape\"\n    ]\n}\n</code></pre> <p>More example assets can be found in the examples/ folder.</p>"},{"location":"OMI_physics_shape/#gltf-schema-updates","title":"glTF Schema Updates","text":"<p>This extension consists of many new data structures for defining physics shapes on the root glTF document and referencing them on a glTF node. The main data structure <code>glTF.OMI_physics_shape.shape.schema.json</code> uses several smaller data structures to define a physics shape. The <code>glTF.OMI_physics_shape.schema.json</code> data structure uses the key <code>\"OMI_physics_shape\"</code> in the document-level <code>\"extensions\"</code> which contains a list of the main physics shape data structures. The <code>node.OMI_physics_shape.schema.json</code> data structure uses the key <code>\"OMI_physics_shape\"</code> in the node-level <code>\"extensions\"</code> which contains an index of the physics shape to use from the list document-level physics shape list.</p> <p>The extension must also be added to the glTF's <code>extensionsUsed</code> array and because it is optional, it does not need to be added to the <code>extensionsRequired</code> array.</p>"},{"location":"OMI_physics_shape/#property-summary","title":"Property Summary","text":"<p>The main data structure <code>glTF.OMI_physics_shape.shape.schema.json</code> defines a type property.</p> Type Description Default value type <code>string</code> The type of the physics shape as a string. Required, no default <p>In addition to the type, a key with the same name as the type can be used to define a sub-JSON with the details of the shape. Which sub-properties are allowed depend on which shape type is being used. The possible properties are described in the following table.</p> Type Description Default value Valid on size <code>number[3]</code> The size of the box shape in meters. [1.0, 1.0, 1.0] Box radius <code>number</code> The radius of the shape in meters. 0.5 Sphere, capsule, cylinder height <code>number</code> The height of the shape in meters. 2.0 Capsule, cylinder mesh <code>number</code> The index of the glTF mesh in the document to use as a mesh shape. -1 Trimesh, convex <p>If a key for the type is missing, or a sub-JSON key is missing, implementations should use the default value. A mesh index of -1 means invalid.</p>"},{"location":"OMI_physics_shape/#shape-types","title":"Shape Types","text":"<p>The <code>\"type\"</code> property is a lowercase string that defines what type of shape this physics shape is.</p> <p>The selection of shapes was carefully chosen with a balance of compatibility between major game engines and containing the most commonly used shapes for easy asset creation. Physics shapes inherit the transform of the glTF node they are attached to. This includes rotation and translation, however it is discouraged to scale physics shape nodes since this can cause problems in some physics engines.</p> <p>Here is a table listing the mapping between the <code>OMI_physics_shape</code> type and the equivalent types in major game engines.</p> Shape Unity Unreal Godot Blender Bullet (Ammo, Panda3D, etc) Box Box Box BoxShape3D Box Box Shape Sphere Sphere Sphere SphereShape3D Sphere Sphere Shape Capsule Capsule Capsule CapsuleShape3D Capsule Capsule Shape Cylinder Approximation Approximation CylinderShape3D Cylinder Cylinder Shape Convex Mesh (Convex) Convex ConvexPolygonShape3D Convex Hull Convex Shape Trimesh Mesh Mesh ConcavePolygonShape3D Mesh Mesh Shape"},{"location":"OMI_physics_shape/#box","title":"Box","text":"<p>Box shapes describe a cube or cuboid shape. They have <code>size</code> property which is an array of 3 numbers that describes the width, height, and depth. If the <code>size</code> property is omitted, the default size is <code>[1, 1, 1]</code>, representing a cube with a volume of one cubic meter, edges/diameters one meter long, and extents/radius of half a meter. The position of the glTF node is the center of the box shape.</p>"},{"location":"OMI_physics_shape/#sphere","title":"Sphere","text":"<p>Sphere shapes describe a uniform \"ball\" shape. They have a <code>radius</code> property which is a single number. If the <code>radius</code> property is omitted, the default radius is <code>0.5</code>, representing a sphere with a radius of half a meter, a diameter of one meter. The position of the glTF node is the center of the sphere shape.</p>"},{"location":"OMI_physics_shape/#capsule","title":"Capsule","text":"<p>Capsule shapes describe a \"pill\" shape. They have a <code>radius</code> and <code>height</code> property. The height is aligned with the node's local vertical axis. If it's desired to align it along a different axis, rotate the glTF node. If the <code>radius</code> property is omitted, the default radius is <code>0.5</code>, and if the <code>height</code> property is omitted, the default height is <code>2.0</code>. The height describes the total height from bottom to top. The height of the capsule must be at least twice as much as the radius. The \"mid-height\" between the centers of each spherical cap end can be found with <code>height - radius * 2.0</code>.</p>"},{"location":"OMI_physics_shape/#cylinder","title":"Cylinder","text":"<p>Cylinder shapes describe a \"tall circle\" shape. They are similar in structure to capsules, they have a <code>radius</code> and <code>height</code> property. The height is aligned with the node's local vertical axis. If it's desired to align it along a different axis, rotate the glTF node. If the <code>radius</code> property is omitted, the default radius is <code>0.5</code>, and if the <code>height</code> property is omitted, the default height is <code>2.0</code>.</p> <p>The use of cylinder is discouraged if another shape would work well in its place. Cylinders are harder to calculate than boxes, spheres, and capsules. Not all game engines support cylinder shapes. Engines that do not support cylinder shapes should use an approximation, such as a convex hull roughly shaped like a cylinder. Cylinders over twice as tall as they are wide can use another approximation: a convex hull combined with an embedded capsule (to allow for smooth rolling), by copying the cylinder's values into a new capsule shape.</p>"},{"location":"OMI_physics_shape/#convex","title":"Convex","text":"<p>Convex shapes represent a convex hull. Being \"convex\" means that the shape cannot have any holes or divots, and that all line segments connecting points on the surface stay within the shape. Convex hulls are defined with a <code>mesh</code> property with an index of a mesh in the glTF <code>meshes</code> array. The glTF mesh in the array MUST be a <code>trimesh</code> to work, and should be made of only one glTF mesh primitive (one surface). Valid convex hulls must contain at least one triangle, which becomes three points on the convex hull. Convex hulls are recommended to have at least four points so that they have 3D volume.</p> <p>Convex hulls can be used to represent complex convex shapes that are not easy to represent with other primitives. If a shape can be represented with a few primitives, prefer using those primitives instead of convex hulls. Convex hulls are much faster than trimesh shapes.</p> <p>When convex hulls are used, asset creators should try to limit the number of vertices in the shape for improved performance and compatibility. Some game engines limit the amount of vertices that can be in a convex hull, which may caused the actual imported shape to be simplified if the shape in the glTF file is too complex.</p>"},{"location":"OMI_physics_shape/#trimesh","title":"Trimesh","text":"<p>Trimesh shapes represent a concave triangle mesh. They are defined with a <code>mesh</code> property with an index of a mesh in the glTF <code>meshes</code> array. The glTF mesh in the array MUST be a <code>trimesh</code> to work, and should be made of only one glTF mesh primitive (one surface). Valid trimesh shapes must contain at least one triangle.</p> <p>Avoid using a trimesh shape for most objects, they are the slowest shapes to calculate and have several limitations. Most physics engines do not support moving trimesh shapes or calculating collisions between multiple trimesh shapes. Trimesh shapes will not work reliably with trigger bodies or with pushing objects out due to not having an \"interior\" space, they only have a surface. Trimesh shapes are typically used for complex level geometry (for example, things that objects can go inside of). If a shape can be represented with a combination of simpler primitives, or a convex hull, or multiple convex hulls, prefer that instead.</p>"},{"location":"OMI_physics_shape/#json-schema","title":"JSON Schema","text":"<p>See glTF.OMI_physics_shape.schema.json for the document-level list of shapes, glTF.OMI_physics_shape.shape.schema.json for the shape resource schema, and the <code>glTF.OMI_physics_shape.shape.*.schema.json</code> files for the individual shape types.</p>"},{"location":"OMI_physics_shape/#known-implementations","title":"Known Implementations","text":"<ul> <li>Godot Engine: https://github.com/godotengine/godot/pull/78967</li> </ul>"},{"location":"OMI_physics_shape/#resources","title":"Resources:","text":"<ul> <li>Godot Shapes: https://docs.godotengine.org/en/latest/classes/class_shape3d.html</li> <li>Unity Colliders: https://docs.unity3d.com/Manual/CollidersOverview.html</li> <li>Unreal Engine Collision Shapes: https://docs.unrealengine.com/4.27/en-US/API/Runtime/PhysicsCore/FCollisionShape/</li> <li>Unreal Engine Mesh Collisions: https://docs.unrealengine.com/4.27/en-US/WorkingWithContent/Types/StaticMeshes/HowTo/SettingCollision/</li> <li>Blender Collisions: https://docs.blender.org/manual/en/latest/physics/rigid_body/properties/collisions.html</li> <li>Mozilla Hubs ammo-shape: https://github.com/MozillaReality/hubs-blender-exporter/blob/bb28096159e1049b6b80da00b1ae1534a6ca0855/default-config.json#L608</li> </ul>"},{"location":"OMI_seat/","title":"OMI_seat","text":""},{"location":"OMI_seat/#contributors","title":"Contributors","text":"<ul> <li>Aaron Franke, The Mirror Megaverse Inc.</li> </ul>"},{"location":"OMI_seat/#status","title":"Status","text":"<p>Open Metaverse Interoperability Group Stage 2 Proposal</p>"},{"location":"OMI_seat/#dependencies","title":"Dependencies","text":"<p>Written against the glTF 2.0 spec.</p> <p>Optionally depends on the <code>OMI_physics_body</code> spec for triggers.</p>"},{"location":"OMI_seat/#overview","title":"Overview","text":"<p>This extension allows defining a glTF node as a seat which a humanoid character can sit on.</p> <p>A seat is defined by specifying the back, foot, and knee positions on the seat from which can be derived the IK positions and directions for placing a humanoid character on that seat. Optionally, the angle between the upper leg and spine can also be defined. This definition supports seats placed in any orientation and supports characters of any size sitting on them.</p> <p>In addition to being defined independently, the <code>OMI_seat</code> extension can be defined on an <code>OMI_physics_body</code> node with the type set to trigger. When <code>OMI_seat</code> is on a trigger, the trigger should be treated as an entry for the seat, such that a player activating that trigger should cause that player to enter the seat.</p> <p>Alternate seated positions, such as a tiny character with straight legs on top of the seat, or a character with their legs crossed on top of the seat, are not the recommended use cases of the seat definition, but are not forbidden if an app wants a character to sit in an unusual position. The primary purpose of this spec is to define the seat itself; how characters sit on that seat is secondary, and the fine details are up to the implementation.</p> <p>This extension does not define any animations for entering or exiting the seat. It also does not define anything that a character's arms, head, tail, or chest should be doing, it only defines information about the seat itself intended to be used to place the legs on the seat.</p>"},{"location":"OMI_seat/#example","title":"Example:","text":"<p>This example defines a seat using a simple chair facing positive Z. This is the same as the <code>simple_chair_pos_z.gltf</code> example, but without the mesh data.</p> <pre><code>{\n    \"asset\": {\n        \"version\": \"2.0\"\n    },\n    \"extensionsUsed\": [\n        \"OMI_seat\"\n    ],\n    \"nodes\": [\n        {\n            \"mesh\": 0,\n            \"name\": \"SimpleChairMesh\"\n        },\n        {\n            \"children\": [\n                0\n            ],\n            \"name\": \"SimpleChairPosZ\",\n            \"extensions\": {\n                \"OMI_seat\": {\n                    \"back\": [0, 0.33, -0.24],\n                    \"foot\": [0, -0.25, 0.3],\n                    \"knee\": [0, 0.33, 0.3]\n                }\n            }\n        }\n    ],\n    \"scene\": 0,\n    \"scenes\": [{ \"nodes\": [1] }],\n}\n</code></pre> <p>More example assets can be found in the examples/ folder.</p>"},{"location":"OMI_seat/#gltf-schema-updates","title":"glTF Schema Updates","text":"<p>This extension consists of one new data structure for defining the seat limits, <code>\"OMI_seat\"</code>. The key <code>\"OMI_seat\"</code> can be added to the node-level <code>\"extensions\"</code> of a glTF node to define a seat.</p> <p>The extension must also be added to the glTF's <code>extensionsUsed</code> array and because it is optional, it does not need to be added to the <code>extensionsRequired</code> array.</p>"},{"location":"OMI_seat/#property-summary","title":"Property Summary","text":"Type Description Default value back <code>number[3]</code> The position limit on the seat corresponding to the character's back in local space. Required, no default foot <code>number[3]</code> The position limit on the seat corresponding to the character's feet in local space. Required, no default knee <code>number[3]</code> The base position on the seat corresponding to the character's knees in local space. Required, no default angle <code>number</code> The angle between the spine and back-knee line in radians. 1.570796... (\u03c4/4 or \u03c0/2 rad, 90 deg) <p>To avoid confusion with different standards of which direction is the forward direction, we define the forward direction by the direction from the back position to the knee position. The up direction is a vector perpendicular to the forward direction such that the direction from the knee to the foot points down. The back, foot, and knee positions should not be colinear or nearly colinear.</p>"},{"location":"OMI_seat/#back","title":"Back","text":"<p>The <code>\"back\"</code> property is a vector as a three-number array that defines the position limit of the character's back and hips in local space.</p> <p>The character's upper leg (thigh) bones are typically placed on lines parallel to the line between the knee and back points, with the lines offset upward based on the thickness of the upper leg and offset to the side based on the desired distance between each leg. If the upper leg is smaller than this line, then the knees are aligned with the knee point, and the hips are moved forward in-between the knee and back points. If the upper leg is larger than this line, then the hips are aligned with the back point, the knees are moved forward farther than the knee point. The knees may also be moved up depending on the foot-knee constraint.</p>"},{"location":"OMI_seat/#foot","title":"Foot","text":"<p>The <code>\"foot\"</code> property is a vector as a three-number array that defines the position limit of the character's feet and lower legs in local space.</p> <p>The character's lower leg (calf) bones are typically placed on lines parallel to the line between the knee and foot points, with the lines offset forward based on the thickness of the lower leg and offset to the side based on the desired distance between each leg. If the lower leg is smaller than this line, then the knees are aligned with the knee point, and the feet are moved upward in-between the knee and back points. If the lower leg is larger than this line, then the feet are aligned with the foot point, and the knee is moved upward farther than the knee point. The knees may also be moved forward depending on the back-knee constraint.</p>"},{"location":"OMI_seat/#knee","title":"Knee","text":"<p>The <code>\"knee\"</code> property is a vector as a three-number array that defines the base position of the character's knees in local space.</p>"},{"location":"OMI_seat/#angle","title":"Angle","text":"<p>The <code>\"angle\"</code> property is a number that defines the angle between the spine and the line connecting the back and knee positions. If not specified, the default value is <code>1.57079632679489662</code> or \u03c4/4 or \u03c0/2, which is 90 degrees represented in radians.</p> <p>This is an angle instead of a position because: * We want to support cases where the character in the seat is smaller than the seat, in which case the hips may be far from the back position in order to place the knees at the knee vector, and the angle between the hips and an upper position would change. Instead we just want to define which direction the spine points. * We do not want to define the upper bound of a seat. A seat should support arbitrarily large characters (if an app wants to limit character size, that's an application-specific constraint beyond the scope of seats), and there is no way to IK a large character within such a constraint without breaking their back or violating other constraints, unlike with the foot/knee/back position. * We want to make this optional for simple use cases. Defining an angle between the spine and back-knee line is unnecessary information for most office chairs, dinner table chairs, and seats without a solid back.</p> <p>This property only needs to be defined when the desired angle between the spine and back-knee line is not 90 degrees. For example, a reclining chair that has a back tilted so the character could lie back should have this defined.</p>"},{"location":"OMI_seat/#property-details","title":"Property Details","text":"<p>The positions defined above can be used to uniquely find other vectors used to place a character on the seat.</p> <ul> <li>The upper leg main direction is the direction from the back vector to the knee vector. This is also the forward direction.</li> <li>The lower leg main direction is the direction from the knee vector to the foot vector.</li> <li>The right direction is the normalized cross product of the lower leg main direction and the upper leg main direction.</li> <li>The upper leg up direction is the cross product of the right direction and the upper leg main direction.</li> <li>The lower leg forward direction is the cross product of the right direction and the lower leg main direction.</li> <li>The spine direction can be found by rotating the upper leg main direction around the right vector by the angle property.</li> </ul> <p>These are the directions of the seat itself, the actual directions a character ends up at may be different. The specifics of this depend on the IK system used. However, one common feature is the need to offset from the seat based on the thickness of the legs in order to determine the points to use for IK, so that we avoid the character's legs being inside of the seat itself.</p> <ul> <li>The IK position for the back/hips/spine is the back position, plus the upper leg thickness times the upper leg up direction, plus the spine thickness times the upper leg main direction.</li> <li>The IK position for the feet is the foot position, plus the lower leg thickness times the lower leg forward direction, minus the foot thickness times the lower leg main direction.</li> <li>The IK position for the knees is more complicated. It needs to be adjusted by both the upper leg and lower leg offsets. For perpendicular upper and lower legs, this is trivial, you just add the vectors together. Otherwise some trigonometry is required. The knee offset can be found by adding the upper leg offset with the upper leg direction multiplied by an adjustment scalar. The adjustment scalar can be found with the lower offset length divided by the sin of the angle between the legs, minus the upper offset length divided by the tan of the angle between the legs.</li> </ul> <p>In a nutshell, the legs sit as close to the seat as possible while not clipping though it, therefore we offset by the leg thickness, otherwise the leg bones would be exactly on the seat's surface. We want to keep the seat's points exactly on the seat and have the character legs offset from the seat's points so that we don't play favorites for any particular leg size.</p>"},{"location":"OMI_seat/#json-schema","title":"JSON Schema","text":"<p>See schema/node.OMI_seat.schema.json for the schema.</p>"},{"location":"OMI_seat/#known-implementations","title":"Known Implementations","text":"<ul> <li>Godot Engine add-on</li> </ul>"},{"location":"OMI_seat/#resources","title":"Resources:","text":"<ul> <li>None</li> </ul>"},{"location":"OMI_spawn_point/","title":"OMI_spawn_point","text":""},{"location":"OMI_spawn_point/#contributors","title":"Contributors","text":"<ul> <li>OMI glTF Extensions Group</li> <li>Robert Long, The Matrix.org Foundation</li> <li>Anthony Burchell, Individual Contributor</li> <li>Aaron Franke, The Mirror Megaverse Inc.</li> </ul>"},{"location":"OMI_spawn_point/#status","title":"Status","text":"<p>Draft Specification</p> <p>Open Metaverse Interoperability Group Stage 1 Proposal</p>"},{"location":"OMI_spawn_point/#dependencies","title":"Dependencies","text":"<p>Written against the glTF 2.0 spec.</p>"},{"location":"OMI_spawn_point/#overview","title":"Overview","text":"<p>The OMI_spawn_point extension allows you to specify a spawn point in a glTF scene, which is a place where spawnable objects can be created, such as characters. This extension can be used on game maps to mark a room or any other location as a spawn point by placing an OMI_spawn_point glTF node at the desired location. This can be useful for VR or AR experiences, where the viewer's starting position and orientation can have a significant impact on the overall experience.</p>"},{"location":"OMI_spawn_point/#example","title":"Example","text":"<p>To use the \"OMI_spawn_point\" extension, you must first specify it in the extensionsUsed property of your glTF file.</p> <pre><code>{\n    \"extensionsUsed\": [\"OMI_spawn_point\"]\n}\n</code></pre> <p>Next, apply the extension to a child node of the glTF file. The node's position and rotation data can be used to determine the location of the spawn point in the scene.</p> <pre><code>{\n    \"nodes\": [\n        {\n            \"name\": \"spawn_point_node\",\n            \"translation\": [0, 0, 1],\n            \"rotation\": [0, 0, 0, 1],\n            \"extensions\": {\n                \"OMI_spawn_point\": {\n                    \"title\": \"Hill East\",\n                    \"team\": \"Red\",\n                    \"group\": \"Hill\"\n                }\n            }\n        }\n    ]\n}\n</code></pre> <p>In the example above, the \"OMI_spawn_point\" extension is applied to a node named \"spawn_point_node\". The node's position and rotation data can be used to determine the location of the spawn point in the scene. The title, team, and group properties are optional and can be used to provide additional information about the spawn point.</p>"},{"location":"OMI_spawn_point/#properties","title":"Properties","text":"<p>All of the properties are optional. An empty JSON object is a valid spawn point. All properties have a default value of null.</p> Type Description title <code>string</code> The title of the spawn point. This can be used as a user-facing name for the spawn point. team <code>string</code> The team that the spawn point is associated with. Ex: \"Red\", \"Blue\", \"Humans\", \"Aliens\", \"Axis\", \"Allies\". group <code>string</code> The group that the spawn point is associated with. This can be used to combine together related spawn points. <p>How each application decides to use the properties, or if they are used at all, is up to that specific implementation's needs.</p> <ul> <li>A game that does not display a menu for spawning does not have to display the title.</li> <li>A game that displays a menu for spawning can generate custom text from the team, group, and/or node name if the title is not specified.</li> <li>A game with no teams does not need to read or use the team property.</li> <li>A game with teams can consider a spawn point without a team assigned as a fallback for when a player is not on a team.</li> <li>A game with no reason to group together spawn points can ignore the group property.</li> </ul>"},{"location":"OMI_spawn_point/#json-schema","title":"JSON Schema","text":"<p>See schema/node.OMI_spawn_point.schema.json for the schema.</p>"},{"location":"OMI_spawn_point/#known-implementations","title":"Known Implementations","text":"<p>Example Three.js implementation - probably not to be included in final proposal</p> <pre><code>// Create a new Three.js scene\nconst scene = new THREE.Scene();\n\n// Set up a perspective camera\nconst camera = new THREE.PerspectiveCamera(\n    75,\n    window.innerWidth / window.innerHeight,\n    0.1,\n    1000\n);\n\n// Load the glTF file\nconst gltfLoader = new THREE.GLTFLoader();\ngltfLoader.load('my-omi-spawn-file.gltf', (gltf) =&gt; {\n    // Add the scene from the glTF file to the Three.js scene\n    scene.add(gltf.scene);\n\n    // Find the \"OMI_spawn_point\" node\n    let spawnPointNode = null;\n    scene.traverse((node) =&gt; {\n        if (node.isObject3D &amp;&amp; node.userData.OMI_spawn_point) {\n            spawnPointNode = node;\n        }\n    });\n\n    // Set the position of the camera to the spawn point position from the source node data.\n    if (spawnPointNode) {\n        camera.position.copy(spawnPointNode.position);\n    }\n});\n</code></pre>"},{"location":"OMI_spawn_point/#known-implementations_1","title":"Known Implementations","text":"<p>Interested Implementations: * INTERESTED AND PENDING - Third Room - https://github.com/thirdroom/thirdroom * INTERESTED AND PENDING - Three Object Viewer (WordPress Plugin) - https://wordpress.org/plugins/three-object-viewer/ * NOT YET PUBLIC - The Mirror https://www.themirror.space/</p>"}]}